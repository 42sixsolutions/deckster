// Generated by CoffeeScript 1.6.3
(function() {
  var $, selector, sym, _ajax_default, _ajax_requests, _create_jump_scroll, _create_jump_scroll_card, _create_jump_scroll_deck, _create_nav_menu, _css_variables, _document, _nav_menu, _nav_menu_options, _ref, _scrollToView;

  _css_variables = {
    selectors: {
      deck: '.deckster-deck',
      card: '.deckster-card',
      card_title: '.deckster-card-title',
      controls: '.deckster-controls',
      drag_handle: '.deckster-drag-handle',
      expand_handle: '.deckster-expand-handle',
      collapse_handle: '.deckster-collapse-handle',
      card_jump_scroll: '.deckster-card-jump-scroll',
      deck_jump_scroll: '.deckster-deck-jump-scroll',
      remove_handle: '.deckster-remove-handle',
      removed_dropdown: '.deckster-removed-dropdown',
      removed_card_li: '.deckster-removed-card-li',
      removed_card_button: '.deckster-removed-card-button',
      add_card_to_bottom_button: '.deckster-add-card-to-bottom-button',
      card_content: '.content',
      placeholders: '.placeholders',
      droppable: '.droppable',
      deck_title: '.deckster-title',
      deck_container: '.deckster-deck-container'
    },
    selector_functions: {
      card_expanded: function(option) {
        return '[data-expanded=' + option + ']';
      },
      deck_expanded: function(option) {
        return '[data-cards-expanded=' + option + ']';
      }
    },
    classes: {},
    dimensions: {},
    styleSheet: "deckster.css",
    chars_to_display: 20,
    buffer: "b"
  };

  /*
    Default Ajax options, some options are typically overwritten.
  */


  _ajax_default = {
    success: function(data, status, response) {
      return console.log("Success: " + status);
    },
    error: function(response, status, exception) {
      return console.log("Status: " + status + " Error: " + exception);
    },
    timeout: 3000,
    type: 'GET',
    async: true
  };

  /*
    Used to keep track of ajax requests. Typically stored as _ajax_requests[deckId][cardId] = $.ajax(...)
  */


  _ajax_requests = {};

  _ref = _css_variables.selectors;
  for (sym in _ref) {
    selector = _ref[sym];
    _css_variables.classes[sym] = selector.slice(1);
  }

  _scrollToView = function($el) {
    var offset;
    offset = $el.offset();
    offset.top -= 20;
    offset.left -= 20;
    return $('html, body').animate({
      scrollTop: offset.top,
      scrollLeft: offset.left
    });
  };

  _nav_menu = null;

  _nav_menu_options = {};

  /*
  # Creates the Bootstrap-based Navigation menu/Jump Scroll bar/Scroll helper from HTML,
  # applies config options, places it in the DOM tree and returns the new element
  */


  _create_nav_menu = function() {
    var button_dom, markup;
    markup = "<div class=\"btn-group " + _css_variables.classes.deck_jump_scroll + "\">\n    <span class=\"dropdown-toggle control jump-deck\" data-toggle=\"dropdown\"></span>\n    <ul class=\"dropdown-menu pull-right\"></ul>\n  </div>\n</div>";
    button_dom = $(markup);
    /* Let the Design/Developer place this in CSS 
    stay_in_view = _nav_menu_options["stay-in-view"]
    if stay_in_view? and not stay_in_view
        outer_el = document
        button_dom.css 'position', 'absolute'
    else
        outer_el = window # outer_el is what we're going to measure to place the button bar
    
    left = false
    x_pos =_nav_menu_options["x-position"]
    calculate_x = () ->
        if x_pos is "left"
            left = "5px"
        else if x_pos is "right"
            button_dom.css "right", "5px"
            button_dom.find("ul.dropdown-menu")
                .removeClass("pull-left")
                .addClass("pull-right")
        else if x_pos is "middle"
            bw = button_dom.find(_css_variables.selectors.deck_jump_scroll)
                    .width()
            left = ($(outer_el).width() - bw) / 2
        else
        if left
            button_dom.css "left", left
    
    y_pos = _nav_menu_options["y-position"]
    top = "5px"
    calculate_top = () ->
        if y_pos is "bottom"
            top = ($(outer_el).height() - button_dom.height()) - 5
            button_dom.addClass("dropup")
        else if y_pos is "middle"
            top = ($(outer_el).height() - button_dom.height()) / 2
        button_dom.css "top", top
     
    # Apply calculate functions once to get approximate positioning
    calculate_x()
    calculate_top()
    */

    $("body").append(button_dom);
    /*
    # Re-calculate with button size known
    calculate_top()
    calculate_x()
    */

    return button_dom;
  };

  _create_jump_scroll = function(target_ul_selector, title_selector, classId) {
    var $item_title_ddl, $title_items;
    if (_nav_menu == null) {
      _nav_menu = _create_nav_menu();
    }
    $item_title_ddl = $(target_ul_selector);
    $item_title_ddl.children().remove();
    $title_items = $(title_selector);
    if ($title_items.length === 0) {
      return;
    }
    return $title_items.each(function(index, item) {
      var $nav_item, elementId, title, _ref1;
      title = $(item).data('title');
      elementId = (_ref1 = $(item).attr("data-card-id")) != null ? _ref1 : $(item).attr("id");
      $nav_item = $("<li id='" + (classId + "-" + elementId) + "'><a href='#'>" + title + "</a></li>");
      $nav_item.on('click', function() {
        return _scrollToView($(item));
      });
      return $item_title_ddl.append($nav_item);
    });
  };

  _create_jump_scroll_card = function($deck) {
    return _create_jump_scroll("#" + $deck.attr("id") + "-nav" + " ul", "#" + $deck.attr("id") + '.deckster-deck [data-title]', _css_variables.classes.card_jump_scroll);
  };

  _create_jump_scroll_deck = function() {
    return _create_jump_scroll("" + _css_variables.selectors.deck_jump_scroll + " ul", '.deckster-deck[data-title]', _css_variables.classes.deck_jump_scroll);
  };

  jQuery.deckster = function(options) {
    console.log("Registering global callbacks");
    return _document.__deck_mgr = options;
  };

  window.Deckster = function(options) {
    var $deck, deckster, init, __$active_drag_card, __active_drag_card_drag_data, __card_data_by_id, __cards_by_id, __cards_needing_resolved_by_id, __cards_needing_resolved_in_order, __col_max, __deck, __default_options, __dominate_card_data, __event_callbacks, __events, __next_id, __row_max, __set_option, _add_back_card, _add_back_card_helper, _add_back_card_to_bottom, _add_card, _add_card_to_jump, _add_placeholders, _adjust_adjacent_decks, _ajax, _apply_deck, _apply_transition, _bind_drag_controls, _card_changed, _clean_up_deck, _collapse_on_click, _create_box, _delete_card_from_removed, _does_fit_location, _expand_on_click, _fit_location, _force_card_to_position, _get_removed_card_li_tag, _identify_problem_cards, _init_card_add_remove, _init_card_scroll, _init_deck_header, _init_deck_wrapper, _loop_through_spaces, _mark_card_as_resolved, _move_card, _move_to_open_position, _on, _placeholder_div, _ref1, _ref2, _ref3, _remove_card_from_deck, _remove_old_position, _remove_on_click, _resolve_card_position, _resolve_cards, _set_new_position, _should_remove_card_in_init;
    $deck = $(this);
    if (!$deck.hasClass(_css_variables.classes.deck)) {
      return console.log('Not a valid deck');
    }
    __default_options = {
      draggable: true,
      expandable: true,
      url_enabled: true,
      removable: true,
      droppable: true
    };
    options = $.extend({}, __default_options, options);
    /* 
    # Modify an option setting (with the config_option key) based on the
    # presence and value of a corresponding data- attribute (data_attr)
    # on the Deck DOM element
    */

    __set_option = function(data_attr, config_option) {
      var option;
      option = $deck.data(data_attr);
      if (option != null) {
        return options[config_option || data_attr] = option === true || option === 'true';
      }
    };
    __set_option('draggable');
    __set_option('expandable');
    __set_option('removable');
    __set_option('url-enabled', 'url_enabled');
    __set_option('droppable');
    /*
       Init Dragging options
    */

    options.animate = (_ref1 = options.animate) != null ? _ref1 : {};
    options.animate.properties = (_ref2 = options.animate.properties) != null ? _ref2 : {};
    options.animate.options = (_ref3 = options.animate.options) != null ? _ref3 : {};
    /*
    # Nav menu options (global)
    */

    $.extend(_nav_menu_options, options["scroll-helper"]);
    /*
      Deckster Base 
     --- Deckster Base Variables
    */

    __next_id = 1;
    __deck = {};
    __cards_by_id = {};
    __card_data_by_id = {};
    __col_max = 0;
    __row_max = 0;
    __cards_needing_resolved_in_order = [];
    __cards_needing_resolved_by_id = {};
    __dominate_card_data = void 0;
    /*
      Registered callbacks events.
    */

    __events = {
      card_added: 'card_added',
      inited: 'inited',
      card_expanded: 'card_expanded',
      card_collapsed: 'card_collapsed',
      card_moved: 'card_moved'
    };
    __event_callbacks = {};
    _on = function(event, callback) {
      if (__event_callbacks[event] == null) {
        __event_callbacks[event] = [];
      }
      return __event_callbacks[event].push(callback);
    };
    _ajax = function(options) {
      options = $.extend(true, {}, _ajax_default, options);
      return $.ajax(options);
    };
    _add_card = function($card, d) {
      var callback, retain_callbacks, _i, _len, _ref4;
      if (d.col_span > __col_max) {
        throw 'Card is too wide';
      }
      _force_card_to_position($card, d, {
        row: d.row,
        col: d.col
      });
      retain_callbacks = [];
      _ref4 = __event_callbacks[__events.card_added] || [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($card, d) !== false) {
          retain_callbacks.push(callback);
        }
      }
      return __event_callbacks[__events.card_added] = retain_callbacks;
    };
    _force_card_to_position = function($card, d, p) {
      if (p.col + (d.col_span - 1) > __col_max) {
        throw 'Card expands out of bounds';
      }
      _mark_card_as_resolved(d);
      __dominate_card_data = d;
      _identify_problem_cards();
      __deck = {};
      _document.__deck_mgr = _document.__deck_mgr || {};
      _loop_through_spaces(p.row, p.col, p.row + (d.row_span - 1), p.col + (d.col_span - 1), function(p2) {
        if (__deck[p2.row] == null) {
          __deck[p2.row] = {};
        }
        return __deck[p2.row][p2.col] = d.id;
      });
      return _resolve_cards();
    };
    _mark_card_as_resolved = function(d) {
      var i;
      if (__cards_needing_resolved_in_order.length > 0) {
        i = $.inArray(d.id, __cards_needing_resolved_in_order);
        if (i > -1) {
          __cards_needing_resolved_in_order.splice(i, 1);
          return delete __cards_needing_resolved_by_id[d.id];
        }
      }
    };
    _identify_problem_cards = function() {
      var col, cols, id, row, _results;
      _results = [];
      for (row in __deck) {
        cols = __deck[row];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (col in cols) {
            id = cols[col];
            if (!(id === void 0 || id === __dominate_card_data.id || (__cards_needing_resolved_by_id[id] != null))) {
              __cards_needing_resolved_by_id[id] = true;
              _results1.push(__cards_needing_resolved_in_order.push(id));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _loop_through_spaces = function(row_start, col_start, row_end, col_end, callback) {
      var col_i, p, r_value, row_i;
      row_i = row_start;
      while (row_i <= row_end) {
        col_i = col_start;
        while (col_i <= col_end) {
          p = {
            row: row_i,
            col: col_i
          };
          r_value = callback(p);
          if (r_value === false) {
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    _resolve_cards = function() {
      var $card, d, id, _results;
      _results = [];
      while (__cards_needing_resolved_in_order.length > 0) {
        id = __cards_needing_resolved_in_order[0];
        $card = __cards_by_id[id];
        d = __card_data_by_id[id];
        _resolve_card_position($card, d);
        _results.push(_mark_card_as_resolved(d));
      }
      return _results;
    };
    _resolve_card_position = function($card, d) {
      var can_go_here, col_i, row_i;
      row_i = 1;
      while (true) {
        if (__deck[row_i] == null) {
          __deck[row_i] = {};
        }
        col_i = 1;
        while (col_i <= (__col_max - d.col_span) + 1) {
          can_go_here = true;
          _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
            if (__deck[p2.row] == null) {
              __deck[p2.row] = {};
            }
            if (__deck[p2.row][p2.col]) {
              can_go_here = false;
              return false;
            }
          });
          if (can_go_here === true) {
            _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
              if (__deck[p2.row] == null) {
                __deck[p2.row] = {};
              }
              return __deck[p2.row][p2.col] = d.id;
            });
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    /*
      Used to transition cards to new positions on the deck. Typical scenario arises when a card is being dragged to a new position and adjacent cards need to be repositioned.
      Transition positions are looked up and cached locally.
    */

    _apply_transition = function($card, d) {
      var colStr, index, leftAnimate, myrules, mysheet, rowStr, rule, sheet, topAnimate, _base, _base1, _i, _j, _len, _len1, _ref4, _ref5;
      rowStr = _css_variables.selectors.card + "[data-row=\"" + d.row + "\"]";
      colStr = _css_variables.selectors.card + "[data-col=\"" + d.col + "\"]";
      _css_variables.dimensions = _css_variables.dimensions || {};
      leftAnimate = _css_variables.dimensions[colStr];
      topAnimate = _css_variables.dimensions[rowStr];
      if (!((leftAnimate != null) && (topAnimate != null))) {
        mysheet = null;
        _ref4 = document.styleSheets;
        for (index = _i = 0, _len = _ref4.length; _i < _len; index = ++_i) {
          sheet = _ref4[index];
          if (_css_variables.styleSheet === sheet.href.split("/").pop()) {
            mysheet = sheet;
            break;
          }
        }
        if (mysheet === null) {
          $card.attr('data-row', d.row);
          $card.attr('data-col', d.col);
          $card.css('opacity', '1');
          return;
        }
        myrules = (_ref5 = mysheet.cssRules) != null ? _ref5 : mysheet.rules;
        for (index = _j = 0, _len1 = myrules.length; _j < _len1; index = ++_j) {
          rule = myrules[index];
          if (rule.selectorText === rowStr) {
            topAnimate = rule.style.top;
            _css_variables.dimensions[rowStr] = topAnimate;
          } else if (rule.selectorText === colStr) {
            leftAnimate = rule.style.left;
            _css_variables.dimensions[colStr] = leftAnimate;
          }
        }
      }
      options.animate.properties.top = topAnimate;
      options.animate.properties.left = leftAnimate;
      if ((_base = options.animate.options).duration == null) {
        _base.duration = "slow";
      }
      if ((_base1 = options.animate.options).easing == null) {
        _base1.easing = "swing";
      }
      options.animate.options.always = function() {
        $card.attr('data-row', d.row);
        $card.attr('data-col', d.col);
        return $card.css('opacity', '1');
      };
      /*
      The animation becomes confusing and inaccurate when to many animations are attempted on the same card;Solution: Stop current and pending animations and start just this one.
      */

      return $card.stop(true, false).animate(options.animate.properties, options.animate.options);
    };
    _apply_deck = function() {
      var $card, applied_card_ids, col, cols, d, id, isDragging, row, row_max, row_max_value;
      row_max = 0;
      applied_card_ids = {};
      isDragging = true;
      for (row in __deck) {
        cols = __deck[row];
        for (col in cols) {
          id = cols[col];
          if (applied_card_ids[id] == null) {
            applied_card_ids[id] = true;
            $card = __cards_by_id[id];
            __card_data_by_id[id].row = parseInt(row);
            __card_data_by_id[id].col = parseInt(col);
            d = __card_data_by_id[id];
            $card.attr('data-card-id', id);
            if (isDragging && !$card.hasClass("draggable")) {
              _apply_transition($card, d);
            } else {
              $card.attr('data-row', d.row);
              $card.attr('data-col', d.col);
            }
            $card.attr('data-row-span', d.row_span);
            $card.attr('data-col-span', d.col_span);
            row_max_value = d.row + d.row_span - 1;
            if (row_max_value > __row_max) {
              __row_max = row_max_value;
            }
          }
        }
      }
      return $deck.attr('data-row-max', row_max);
    };
    /*
    # Initially, cards will be hidden if the 'data-hidden' attribute is true, or
    #   if the deck's 'remove-empty' attribute is true, and
    #   there is no card content, and
    #   there is no 'data-url' attribute
    */

    _should_remove_card_in_init = function($card, $deck) {
      return $card.data('hidden') === true || ($deck.data('remove-empty') === true && !$card.find(_css_variables.selectors.card_content).text().trim() && !$card.data('url'));
    };
    _init_deck_header = function($deck) {
      var $deck_wrapper, $dropdown, title;
      title = $deck.data("title");
      if (!title) {
        $deck.attr("data-title", $deck.attr("id"));
        title = $deck.attr("id");
      }
      $deck_wrapper = $(_init_deck_wrapper($deck));
      $deck.replaceWith($deck_wrapper);
      $deck_wrapper.append($deck);
      $dropdown = $deck_wrapper.find(_css_variables.selectors.removed_dropdown);
      if ($dropdown.find('ul').children().size() === 0) {
        $dropdown.hide();
      }
      return true;
    };
    _init_deck_wrapper = function($deck) {
      return "<div class=\"" + _css_variables.classes.deck_container + "\">\n  <div class=\"deck-header\">\n    <div class=\"wrapper\">\n      <div class=\"" + _css_variables.classes.deck_title + "\">" + ($deck.data("title") || "") + "</div>\n      <div class=\"deck-controls\">\n        " + (_init_card_add_remove()) + "\n        " + (_init_card_scroll($deck)) + "\n      </div>\n    </div>\n  </div>";
    };
    _init_card_add_remove = function() {
      return "<div class=\"btn-group " + _css_variables.classes.removed_dropdown + "\">\n  <span class=\"dropdown-toggle control add\" data-toggle=\"dropdown\"></span>\n  <ul class=\"dropdown-menu pull-right\"></ul>\n</div>";
    };
    _init_card_scroll = function($deck) {
      return "<div id=\"" + ($deck.attr("id")) + "-nav\" class=\"btn-group " + _css_variables.classes.card_jump_scroll + "\">\n  <span class=\"dropdown-toggle control jump-card\" data-toggle=\"dropdown\"></span>\n  <ul class=\"dropdown-menu pull-right\"></ul>\n</div>";
    };
    init = function() {
      var callback, cards, _i, _len, _ref4;
      __col_max = $deck.data('col-max');
      _init_deck_header($deck);
      cards = $deck.children(_css_variables.selectors.card);
      cards.each(function() {
        var $card, $cheight, $theight, d;
        $card = $(this);
        if (_should_remove_card_in_init($card, $deck)) {
          $card.remove();
        } else {
          d = {
            id: __next_id++,
            row: parseInt($card.attr('data-row')),
            col: parseInt($card.attr('data-col')),
            row_span: parseInt($card.attr('data-row-span')),
            col_span: parseInt($card.attr('data-col-span'))
          };
          __cards_by_id[d.id] = $card;
          __card_data_by_id[d.id] = d;
          _add_card($card, d);
        }
        $cheight = $(this).height();
        $theight = $('.deckster-card-title', this).height() + 40;
        $('.deckster-card-title', this).css('margin-top', -$theight);
        return $(this).css('padding-top', $theight);
      });
      _apply_deck();
      cards.append("<div class='" + _css_variables.classes.controls + "'></div>");
      _ref4 = __event_callbacks[__events.inited] || [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($deck) === false) {
          break;
        }
      }
      _create_jump_scroll_card($deck);
      return _create_jump_scroll_deck(0xDEADBEEF);
    };
    _adjust_adjacent_decks = function($deck) {
      /*
      deckId = $deck.attr("id")
      specs = _window.__deck_mgr.lookup[deckId]
      new_layout = {}
        
      #copy decks up to deck being modified
      for row in [1...specs.row_min]
        new_layout[row] = _window.__deck_mgr.layout[row]
        
      
      #add current deck 
      for row,cols of __deck
        new_layout[specs.row_min-1+row] = {}
        new_layout[specs.row_min-1+row][col] = deckId for col in [1..__col_max]
      
      #add back buffer
      newRow = __row_max+specs.row_min
      new_layout[newRow] = {}
      new_layout[newRow][i] = _css_variables.buffer for i in [1..__col_max]
      
      # copy rest 
      # (note: our previous buffer, for this deck, will be copied over when iterating 
      # over the 'specs.row_max' row)
      newRow += 1
      prevId = -1
      for row in [(specs.row_max+1).._window.__deck_mgr.row]
        new_layout[newRow] = _window.__deck_mgr.layout[row]
       
        # Update global deck placements
        id = new_layout[newRow][1] #
        if id != prevId and id != _css_variables.buffer
          _window.__deck_mgr.lookup[id].row_min = newRow
          _window.__deck_mgr.lookup[id].row_max = newRow
          prevId = id
        else
          _window.__deck_mgr.lookup[prevId].row_max = newRow
      
      
        newRow+=1
      */

      /*
        Update global variables.
        -New overall max row (note: the for loop increments this value 1 extra time when exiting for-loop)
        -New Layout
        -Deck Max
      */

      /*
      _window.__deck_mgr.row = newRow-1 
      console.log("_window.__deck_mgr.row",_window.__deck_mgr.row)
      _window.__deck_mgr.layout = new_layout # new layout
      console.log("layout",_window.__deck_mgr.layout)
      console.log("__row_max!",__row_max)
      _window.__deck_mgr.lookup[deckId].row_max = specs.row_min+__row_max
      */

      $deck.closest(_css_variables.selectors.deck_container).attr("data-row-max", __row_max + 1);
      return true;
    };
    /*
      Adjust (if necessary) other decks when a particular deck is expanded/collapsed or its contents are moved around.
    */

    _on(__events.card_collapsed, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.card_expanded, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.card_moved, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.inited, function($deck) {
      /*
      col_min = 1 # Should only be 1 as we will only be scrolling vertically 
      deckId = $deck.attr("id")
      #How many decks "rows" are there currently?
      if _window.__deck_mgr.row?  
        #Start at the next available row
        row_min = _window.__deck_mgr.row+1
      else 
        row_min = 1
      
      #Max width for this deck
      col_max = __col_max
      #There's an extra row between decks to act as a buffer
      row_max = row_min+__row_max
      
      _window.__deck_mgr.layout = _window.__deck_mgr.layout || {} 
      for y in [row_min..row_max]
        for x in [col_min..col_max]
      
          unless _window.__deck_mgr.layout[y]
            _window.__deck_mgr.layout[y] = {}
      
          _window.__deck_mgr.layout[y][x] = if y == row_max then _css_variables.buffer else $deck.attr("id")
      
      #Maximum number of rows 
      _window.__deck_mgr.row = row_max
      _window.__deck_mgr.lookup = _window.__deck_mgr.lookup || {}
      #Record results
      _window.__deck_mgr.lookup[deckId] =
        "row_min":row_min
        "row_max":row_max
        "col_max":col_max
        "col_min":col_min
      */

      $deck.closest(_css_variables.selectors.deck_container).attr("data-row-max", __row_max + 1);
      return true;
    });
    if (options['draggable'] && options['draggable'] === true) {
      __$active_drag_card = void 0;
      __active_drag_card_drag_data = void 0;
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a class='" + _css_variables.classes.drag_handle + " control drag'></a>";
        return $deck.find(_css_variables.selectors.controls).append(controls);
      });
      _on(__events.inited, function($deck) {
        return _bind_drag_controls(this);
      });
      _create_box = function($card, clazz) {
        var $div;
        $div = $("<div/>").addClass(clazz).addClass("deckster-card").attr("data-col", $card.attr("data-col")).attr("data-row", $card.attr("data-row")).attr("data-col-span", $card.attr("data-col-span")).attr("data-row-span", $card.attr("data-row-span"));
        return $div;
      };
      _bind_drag_controls = function(deck) {
        $deck.find(_css_variables.selectors.drag_handle).on("mousedown", function(e) {
          var $drag_handle;
          $drag_handle = $(this);
          __$active_drag_card = $drag_handle.parents(_css_variables.selectors.card);
          __$active_drag_card.addClass('draggable');
          __$active_drag_card.css('z-index', 1000);
          $deck.append(_create_box(__$active_drag_card, "shadowbox"));
          __$active_drag_card.css('z-index', '1000');
          __active_drag_card_drag_data = {
            height: __$active_drag_card.outerHeight(),
            width: __$active_drag_card.outerWidth(),
            pos_y: __$active_drag_card.offset().top + __$active_drag_card.outerHeight() - e.pageY,
            pos_x: __$active_drag_card.offset().left + __$active_drag_card.outerWidth() - e.pageX
          };
          __active_drag_card_drag_data['original_top'] = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
          __active_drag_card_drag_data['original_left'] = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
          return e.preventDefault();
        });
        $deck.on('mousemove', function(e) {
          var $shadowbox, left, messages, new_left, new_top, original_left, original_top, top;
          if (__$active_drag_card != null) {
            new_top = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
            new_left = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
            original_left = __active_drag_card_drag_data['original_left'];
            original_top = __active_drag_card_drag_data['original_top'];
            $shadowbox = $(".shadowbox");
            top = parseInt($shadowbox.attr("data-row"));
            left = parseInt($shadowbox.attr("data-col"));
            messages = [];
            if (new_top - original_top < -200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] - 200;
              _move_card(__$active_drag_card, "up");
              top -= 1;
              messages.push('UP');
            }
            if (new_top - original_top > 200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] + 200;
              _move_card(__$active_drag_card, "down");
              top += 1;
              messages.push('DOWN');
            }
            if (new_left - original_left < -300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] - 300;
              _move_card(__$active_drag_card, "left");
              left -= 1;
              messages.push('LEFT');
            }
            if (new_left - original_left > 300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] + 300;
              _move_card(__$active_drag_card, "right");
              left += 1;
              messages.push('RIGHT');
            }
            if (messages.length > 0) {
              console.log(messages.join(' '));
            }
            $shadowbox.attr("data-col", left);
            $shadowbox.attr("data-row", top);
            return __$active_drag_card.offset({
              top: new_top,
              left: new_left
            });
          }
        });
        return $deck.on('mouseup', function(e) {
          if (__$active_drag_card != null) {
            __$active_drag_card.removeClass('draggable');
            __$active_drag_card.css('top', '');
            __$active_drag_card.css('left', '');
            __$active_drag_card.css('z-index', '');
            __$active_drag_card.css('opacity', '1');
            $(".shadowbox").fadeOut("slow", function() {
              return $(this).remove();
            });
            __$active_drag_card = void 0;
            return __active_drag_card_drag_data = void 0;
          }
        });
      };
      _move_card = function($card, direction) {
        var d, id;
        id = $card.data('card-id');
        d = __card_data_by_id[id];
        switch (direction) {
          case 'left':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col - 1
            });
            break;
          case 'right':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col + 1
            });
            break;
          case 'up':
            _force_card_to_position($card, d, {
              row: d.row - 1,
              col: d.col
            });
            break;
          case 'down':
            _force_card_to_position($card, d, {
              row: d.row + 1,
              col: d.col
            });
        }
        return _apply_deck();
      };
    }
    if (options['expandable'] && options['expandable'] === true) {
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a class='" + _css_variables.classes.expand_handle + " control expand'></a>\n<a class='" + _css_variables.classes.collapse_handle + " control collapse' style='display:none;'></a>";
        $deck.find(_css_variables.selectors.controls).append(controls);
        $deck.find(_css_variables.selectors.expand_handle).click(function() {
          return _expand_on_click(this);
        });
        return $deck.find(_css_variables.selectors.collapse_handle).click(function() {
          return _collapse_on_click(this);
        });
      });
      _expand_on_click = function(element) {
        var $card, $expand_handle, callback, d, expandColTo, expandRowTo, id, _i, _len, _ref4, _results;
        $expand_handle = $(element);
        $card = $expand_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        console.log([
          'Expand <<<', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        $card.attr('data-original-col', d.col);
        $card.attr('data-original-row-span', d.row_span);
        $card.attr('data-original-col-span', d.col_span);
        if ($card.data("col-expand") != null) {
          expandColTo = parseInt($card.data("col-expand"));
          expandColTo = expandColTo > __col_max ? __col_max : expandColTo;
        }
        expandColTo = (expandColTo != null) && expandColTo > 0 ? expandColTo : d.col_span;
        if ($card.data("row-expand") != null) {
          expandRowTo = parseInt($card.data("row-expand"));
        }
        expandRowTo = (expandRowTo != null) && expandRowTo > 0 ? expandRowTo : d.row_span;
        d['row_span'] = expandRowTo;
        d['col'] = (expandColTo - 1) + d.col <= __col_max ? d.col : 1;
        d['col_span'] = expandColTo;
        if (d.col_span === $card.data('original-col-span') && d.row_span === $card.data('original-row-span')) {
          return;
        }
        console.log([
          'Expand >>>', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $expand_handle.hide();
        $expand_handle.siblings(_css_variables.selectors.collapse_handle).show();
        _ref4 = __event_callbacks[__events.card_expanded] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _collapse_on_click = function(element) {
        var $card, $collapse_handle, callback, d, id, _i, _len, _ref4, _results;
        $collapse_handle = $(element);
        $card = $collapse_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        d.col = parseInt($card.attr('data-original-col'));
        d.row_span = parseInt($card.attr('data-original-row-span'));
        d.col_span = parseInt($card.attr('data-original-col-span'));
        $card.attr('data-original-col', '');
        $card.attr('data-original-row-span', '');
        $card.attr('data-original-col-span', '');
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $collapse_handle.hide();
        $collapse_handle.siblings(_css_variables.selectors.expand_handle).show();
        _clean_up_deck();
        _ref4 = __event_callbacks[__events.card_collapsed] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _on(__events.inited, function() {
        return $(_css_variables.selectors.deck + ":not(" + _css_variables.selector_functions.deck_expanded(false) + ")").each(function(index) {
          $deck = $(this);
          return $deck.find(_css_variables.selectors.card + ":not(" + _css_variables.selector_functions.card_expanded(false) + ")").each(function(index) {
            return $(this).find(_css_variables.selectors.expand_handle).trigger("click");
          });
        });
      });
      _card_changed = function($deck, $card, type) {
        var $cardContent, action, ajaxOptions, cardActions, cardId, cardIdentity, deckId, temp;
        if ((options["card-actions"] != null) && (options["card-actions"][type] != null)) {
          cardActions = options["card-actions"][type];
          deckId = $deck.attr("id");
          cardId = $card.attr("id");
          $cardContent = $card.find(_css_variables.selectors.card_content);
          for (cardIdentity in cardActions) {
            action = cardActions[cardIdentity];
            if ("#" + $card.attr("id") === cardIdentity || $card.hasClass(cardIdentity.slice(1)) || cardIdentity === "*") {
              temp = action($card, $cardContent);
              if ((temp != null) && (temp.url != null)) {
                /*
                   Abort any requests that are currently on-going.
                */

                if (_ajax_requests[deckId] && _ajax_requests[deckId][cardId]) {
                  _ajax_requests[deckId][cardId].abort();
                  delete _ajax_requests[deckId][cardId];
                  /*
                    Send the ajax request after any card animation has finished (Typically when a card is expanded its size will be changed.) For example, trying to animate and load content into the card makes both operations laggy and detract from the user experience.
                  */

                }
                ajaxOptions = temp;
                $card.queue().push(function() {
                  return _ajax_requests[deckId][cardId] = _ajax(ajaxOptions);
                });
              }
            }
          }
        }
        /* Call any globally registered callbacks*/

        if ((_document.__deck_mgr != null) && (_document.__deck_mgr["card-actions"] != null) && (_document.__deck_mgr["card-actions"][type] != null)) {
          return _document.__deck_mgr["card-actions"][type]($card, $cardContent);
        }
      };
      _on(__events.card_expanded, function($deck, $card) {
        return _card_changed($deck, $card, "card-expanded");
      });
      _on(__events.card_collapsed, function($deck, $card) {
        return _card_changed($deck, $card, "card-collapsed");
      });
    }
    /*
      Setting url_enabled to true allows ajax requests to run.
    */

    if (options['url_enabled'] === true) {
      _on(__events.card_added, function($card, d) {
        var ajax_options, cardId, deckId;
        if ($card.data("url") != null) {
          ajax_options = {
            url: $card.data("url"),
            type: $card.data("url-method") != null ? $card.data("url-method") : "GET",
            context: $card,
            success: function(data, status, response) {
              var $controls, $title, divText;
              if (!!data.trim()) {
                $controls = this.find(_css_variables.selectors.controls).clone(true);
                $title = this.find(_css_variables.selectors.card_title);
                this.html("");
                this.append($title);
                this.append($controls);
                return this.append('<div class="content">' + data + '</div>');
              } else {
                divText = this.find(_css_variables.selectors.card_content).text();
                if (!divText.trim() && $deck.data('remove-empty') === true) {
                  _create_jump_scroll_card($deck);
                  this.remove();
                  return _remove_card_from_deck(this);
                }
              }
            }
          };
          deckId = $card.closest(_css_variables.selectors.deck).attr("id");
          cardId = $card.attr("id");
          /*
           Keep track of requests incase we need to abort them.
          */

          _ajax_requests[deckId] = _ajax_requests[deckId] || {};
          return _ajax_requests[deckId][cardId] = _ajax(ajax_options);
        }
      });
    }
    /*
      Droppable Helper Methods:
    */

    _placeholder_div = function($card, _d, settings) {
      var $placeholder, height, width;
      width = $card.outerWidth();
      height = $card.outerHeight();
      $placeholder = $("<div>").addClass("placeholders").addClass(_css_variables.selectors.card.substring(1)).attr("data-col", _d["col"]).attr("data-row", _d["row"]).attr("data-col-span", _d.col_span).attr("data-row-span", _d.row_span).css("z-index", settings.zIndex);
      $card.closest(_css_variables.selectors.deck).append($placeholder);
      $placeholder.click(function(action) {
        var $selectedCard;
        _remove_old_position($card, __card_data_by_id[_d.id]);
        $selectedCard = $(action.currentTarget);
        __card_data_by_id[_d.id] = _d;
        _set_new_position($card, _d);
        _apply_transition($card, _d);
        return $card.find(_css_variables.selectors.droppable).trigger("click");
      });
      $placeholder.mouseenter(function(action) {
        $(this).data("prev-z-index", $(this).css("z-index"));
        return $(this).css("z-index", 1000);
      });
      $placeholder.mouseleave(function(action) {
        return $(this).css("z-index", $(this).data("prev-z-index"));
      });
      return $card;
    };
    _remove_old_position = function($card, d) {
      var col_end, col_remove, row_end, row_remove, _i, _j, _ref4, _ref5;
      row_end = d.row + d.row_span - 1;
      col_end = d.col + d.col_span - 1;
      for (row_remove = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_remove = _ref4 <= row_end ? ++_i : --_i) {
        for (col_remove = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_remove = _ref5 <= col_end ? ++_j : --_j) {
          if (!__deck[row_remove]) {
            break;
          }
          if (__deck[row_remove][col_remove] === d.id) {
            delete __deck[row_remove][col_remove];
          }
        }
      }
      return true;
    };
    _set_new_position = function($card, d) {
      var col_add, col_end, row_add, row_end, _i, _j, _ref4, _ref5;
      row_end = d.row_span + d.row - 1;
      col_end = d.col_span + d.col - 1;
      for (row_add = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_add = _ref4 <= row_end ? ++_i : --_i) {
        if (!__deck[row_add]) {
          __deck[row_add] = {};
        }
        for (col_add = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_add = _ref5 <= col_end ? ++_j : --_j) {
          __deck[row_add][col_add] = d.id;
        }
      }
      if (row_end > __row_max) {
        __row_max = row_end;
      }
      _clean_up_deck();
      return true;
    };
    _clean_up_deck = function() {
      var row_subtractor, _results;
      row_subtractor = __row_max;
      _results = [];
      while (row_subtractor > 0) {
        if ($.isEmptyObject(__deck[row_subtractor])) {
          delete __deck[row_subtractor];
          if (__row_max === row_subtractor) {
            __row_max -= 1;
          }
        }
        _results.push(row_subtractor -= 1);
      }
      return _results;
    };
    _fit_location = function(row, col, d) {
      var col_end, col_test, row_end, row_test, _i, _j;
      row_end = d.row_span + row - 1;
      col_end = d.col_span + col - 1;
      if (col_end > __col_max) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (__deck[row_test] && __deck[row_test][col_test]) {
            return false;
          }
        }
      }
      return true;
    };
    _add_placeholders = function($card, d) {
      var b, col, g, new_d, r, row, zIndex, _i, _j, _ref4;
      zIndex = 1;
      r = 0;
      g = 25;
      b = 50;
      for (row = _i = 1, _ref4 = __row_max + 1; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; row = 1 <= _ref4 ? ++_i : --_i) {
        for (col = _j = 1; 1 <= __col_max ? _j <= __col_max : _j >= __col_max; col = 1 <= __col_max ? ++_j : --_j) {
          if (_fit_location(row, col, d)) {
            new_d = {
              "id": d.id,
              "row": row,
              "col": col,
              "row_span": d.row_span,
              "col_span": d.col_span
            };
            _placeholder_div($card, new_d, {
              "zIndez": zIndex,
              "r": r,
              "g": g,
              "b": b
            });
            zIndex += 1;
            r = (r + 0) % 200;
            g = (g + 50) % 150;
            b = (b + 50) % 250;
          }
        }
      }
      return -1;
    };
    /* 
      If set to true, cards can be picked up and dropped to a new spot on the deck without disturbing the positions of any other card.
      :Droppable Helper Methods End.
    */

    if (options.droppable === true) {
      _on(__events.inited, function($card, d) {
        var $controls, $droppable;
        $controls = $card.find(_css_variables.selectors.controls);
        $droppable = $("<a></a>").addClass(_css_variables.selectors.droppable.substring(1) + ' control droppable1');
        $droppable.click(function(element) {
          var $drop_handle, callback, id, retain_callbacks, _i, _len, _ref4;
          $drop_handle = $(element.currentTarget);
          if (!$drop_handle.hasClass("cancel")) {
            $card = $drop_handle.closest(_css_variables.selectors.card);
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(":visible").addClass("hider").hide();
            $deck.closest(_css_variables.selectors.deck_container).nextAll(_css_variables.selectors.deck_container).hide();
            $drop_handle.show();
            $drop_handle.addClass("cancel");
            id = parseInt($card.attr('data-card-id'));
            d = __card_data_by_id[id];
            return _add_placeholders($card, d);
          } else {
            $drop_handle.removeClass("cancel");
            $card = $drop_handle.closest(_css_variables.selectors.card);
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(".hider").show().removeClass("hider");
            $deck.find(_css_variables.selectors.placeholders).remove();
            $(document).find(_css_variables.selectors.deck_container).show();
            retain_callbacks = [];
            _ref4 = __event_callbacks[__events.card_moved] || [];
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              callback = _ref4[_i];
              if (callback($deck, $card) !== false) {
                retain_callbacks.push(callback);
              }
            }
            return __event_callbacks[__events.card_moved] = retain_callbacks;
          }
        });
        return $controls.append($droppable);
      });
    }
    if (true) {
      _on(__events.card_added, function($card, d) {
        var $title_div, title;
        title = $card.data("title");
        if (!((title != null) && !$card.find(_css_variables.selectors.card_title).text())) {
          return;
        }
        $title_div = $('<div>').text(title).addClass(_css_variables.classes.card_title);
        return $card.prepend($title_div);
      });
    }
    if (options['removable'] && options['removable'] === true) {
      _on(__events.inited, function($card) {
        var controls;
        controls = "<a class='" + _css_variables.classes.remove_handle + " control remove'></a>";
        $card.find(_css_variables.selectors.controls).append(controls);
        return $card.find(_css_variables.selectors.remove_handle).click(function() {
          return _remove_on_click(this);
        });
      });
      _remove_on_click = function(element) {
        var $card, $content, $dropdown, $remove_handle, cardId, charLen, d, deckId, titleText;
        $remove_handle = $(element);
        $card = $remove_handle.closest(_css_variables.selectors.card);
        cardId = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[cardId];
        $deck = $card.closest(_css_variables.selectors.deck);
        deckId = $deck.attr("id");
        /* Set Title*/

        titleText = $card.find(_css_variables.selectors.card_title).text();
        if (!titleText.length) {
          $content = $card.find(_css_variables.selectors.card_content);
          charLen = _css_variables.chars_to_display;
          if ($content.text().length < _css_variables.chars_to_display) {
            charLen = $content.text().length;
          }
          titleText = $content.text().substring(0, charLen) + "...";
        }
        /* Dropdown Handle*/

        $dropdown = $deck.closest(_css_variables.selectors.deck_container).find(_css_variables.selectors.removed_dropdown);
        if ($dropdown.is(":hidden")) {
          $dropdown.show();
        }
        $dropdown.find('ul').append(_get_removed_card_li_tag(cardId, titleText));
        /* 
        Event is currently unpredictable, hold off for now.
        Add card back to orig position (moving other cards if necessary)
        $dropdown.find('#'+_css_variables.classes.removed_card_button + '-' + cardId).click ->
          _add_back_card(cardId)
        */

        /* Add card to open position*/

        $dropdown.find('#' + _css_variables.classes.removed_card_button + '-' + cardId).click(function() {
          return _move_to_open_position(cardId, $dropdown);
        });
        /* Detach card from deck*/

        $card.detach();
        /* Remove this card from the __deck variable*/

        _remove_old_position($card, d);
        $dropdown.siblings("#" + deckId + "-nav").find("#" + _css_variables.classes.card_jump_scroll + "-" + cardId).remove();
        return _clean_up_deck();
      };
      _move_to_open_position = function(cardId, $dropdown) {
        var $card, d;
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        $deck.append($card.hide());
        _on(__events.card_moved, function($deck, $card) {
          /*
            Show card once any transition animations are complete (which are called when a user selects a new spot.)
          */

          $card.queue().push(function() {
            return $card.show();
          });
          _add_card_to_jump($card, $dropdown);
          return false;
        });
        _delete_card_from_removed(d.id, $dropdown);
        return $card.find(_css_variables.selectors.droppable).trigger("click");
      };
      _delete_card_from_removed = function(cardId, $dropdown) {
        $dropdown.find('#' + _css_variables.classes.removed_card_li + '-' + cardId).remove();
        if ($dropdown.find('ul').children().size() === 0) {
          return $dropdown.hide();
        }
      };
      _add_card_to_jump = function($card, $dropdown) {
        var $nav_item, classId, elementId, title;
        if (($card.data("title") != null)) {
          title = $card.data('title');
          elementId = $card.attr("data-card-id");
          classId = _css_variables.classes.card_jump_scroll;
          $nav_item = $("<li id='" + (classId + "-" + elementId) + "'><a href='#'>" + title + "</a></li>");
          $nav_item.on('click', function() {
            return _scrollToView($card);
          });
          return $dropdown.siblings(_css_variables.selectors.card_jump_scroll).find('ul').append($nav_item);
        }
      };
      /*
      # Removes the card from the __deck variable so that it doesn't take up space once removed
      */

      _remove_card_from_deck = function($card) {
        var cardId, col, cols, id, row;
        cardId = parseInt($card.attr('data-card-id'));
        for (row in __deck) {
          cols = __deck[row];
          for (col in cols) {
            id = cols[col];
            if (cardId === id) {
              delete __deck[row][col];
              if ($.isEmptyObject(__deck[row])) {
                delete __deck[row];
              }
            }
          }
        }
        return void 0;
      };
      /*
      # Returns the <li> tag for this card, to be shown within the 'Removed Card' dropdown.
      # It displays the card title (or the first 15 characters of the card content, if no title),
      #   and an 'Add' button.
      */

      _get_removed_card_li_tag = function(id, titleText) {
        return "<li id=" + _css_variables.classes.removed_card_li + "-" + id + "\nclass=" + _css_variables.classes.removed_card_li + ">\n<a id=" + _css_variables.classes.removed_card_button + "-" + id + ">\n" + titleText + "\n</a>\n</li>";
      };
      /*
      # This is the callback when the 'Add' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card = function(cardId) {
        var $card, d;
        if (cardId == null) {
          return;
        }
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        return _add_back_card_helper(cardId, $card, d);
      };
      /*
      # This is the callback when the 'Add to bottom ' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card_to_bottom = function(cardId) {
        var $card, can_fit_in_last_row, col, d, _i;
        if (cardId == null) {
          return;
        }
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        can_fit_in_last_row = false;
        for (col = _i = 1; _i <= __col_max; col = _i += 1) {
          if (_does_fit_location(__row_max, col, d)) {
            can_fit_in_last_row = true;
            console.log("fits in max row: __row_max, col: " + __row_max, col);
            break;
          } else {
            console.log$("doesn't fit in max row: __row_max, col: " + __row_max, col);
          }
        }
        if (can_fit_in_last_row) {
          d.row = __row_max;
          d.col = col;
        } else {
          d.row = __row_max + 1;
          d.col = 1;
        }
        return _add_back_card_helper(cardId, $card, d);
      };
      _add_back_card_helper = function(cardId, $card, d) {
        var dropdown;
        $deck.append($card);
        _add_card($card, d);
        _apply_deck();
        _create_jump_scroll_card($deck);
        $deck.parent().find('#' + _css_variables.classes.removed_card_li + '-' + cardId).remove();
        dropdown = $deck.parent().find(_css_variables.selectors.removed_dropdown);
        if (dropdown.find('ul').children().size() === 0) {
          return dropdown.hide();
        }
      };
    }
    _does_fit_location = function(row, col, d) {
      var col_end, col_test, row_end, row_test, _i, _j;
      row_end = d.row_span + row;
      col_end = d.col_span + col;
      if (col_end - 1 > __col_max) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (__deck[row_test] && __deck[row_test][col_test]) {
            return false;
          }
        }
      }
      return true;
    };
    init();
    return deckster = {
      deck: __deck,
      on: _on,
      events: __events
    };
  };

  $ = jQuery;

  $.fn.deckster = window.Deckster;

  _document = $(document);

}).call(this);
