// Generated by CoffeeScript 1.6.3
(function() {
  var $, selector, sym, _ajax_default, _ajax_requests, _create_jump_scroll, _create_jump_scroll_card, _create_jump_scroll_deck, _create_nav_menu, _css_variables, _nav_menu, _nav_menu_options, _ref, _scrollToView;

  _css_variables = {
    selectors: {
      deck: '.deckster-deck',
      card: '.deckster-card',
      card_title: '.deckster-card-title',
      controls: '.deckster-controls',
      drag_handle: '.deckster-drag-handle',
      expand_handle: '.deckster-expand-handle',
      collapse_handle: '.deckster-collapse-handle',
      card_jump_scroll: '.deckster-card-jump-scroll',
      deck_jump_scroll: '.deckster-deck-jump-scroll',
      remove_handle: '.deckster-remove-handle',
      removed_dropdown: '.deckster-removed-dropdown',
      removed_card_li: '.deckster-removed-card-li',
      removed_card_button: '.deckster-removed-card-button',
      add_card_to_bottom_button: '.deckster-add-card-to-bottom-button',
      card_content: '.content',
      placeholders: '.placeholders',
      droppable: '.droppable'
    },
    selector_functions: {
      card_expanded: function(option) {
        return '[data-expanded=' + option + ']';
      },
      deck_expanded: function(option) {
        return '[data-cards-expanded=' + option + ']';
      }
    },
    classes: {},
    dimensions: {},
    styleSheet: "deckster.css"
  };

  /*
    Default Ajax options, some options are typically overwritten.
  */


  _ajax_default = {
    success: function(data, status, response) {
      return console.log("Success: " + status);
    },
    error: function(response, status, exception) {
      return console.log("Status: " + status + " Error: " + exception);
    },
    timeout: 3000,
    type: 'GET',
    async: true
  };

  /*
    Used to keep track of ajax requests. Typically stored as _ajax_requests[deckId][cardId] = $.ajax(...)
  */


  _ajax_requests = {};

  _ref = _css_variables.selectors;
  for (sym in _ref) {
    selector = _ref[sym];
    _css_variables.classes[sym] = selector.slice(1);
  }

  _scrollToView = function($el) {
    var offset;
    offset = $el.offset();
    offset.top -= 20;
    offset.left -= 20;
    return $('html, body').animate({
      scrollTop: offset.top,
      scrollLeft: offset.left
    });
  };

  _nav_menu = null;

  _nav_menu_options = {};

  /*
  # Creates the Bootstrap-based Navigation menu/Jump Scroll bar/Scroll helper from HTML,
  # applies config options, places it in the DOM tree and returns the new element
  */


  _create_nav_menu = function() {
    var button_dom, calculate_top, calculate_x, left, markup, outer_el, stay_in_view, top, x_pos, y_pos;
    markup = "<div id=\"deckster-scroll-helper\" class=\"btn-group\">\n  <div class=\"btn-group " + _css_variables.classes.card_jump_scroll + "\">\n    <button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\">\n      JC <!-- \"jump [to] card\" -->\n      <span class=\"caret\"></span>\n    </button>\n    <ul class=\"dropdown-menu pull-left\">\n    </ul>\n  </div>\n  <div class=\"btn-group " + _css_variables.classes.deck_jump_scroll + "\">\n    <button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\">\n        JD<!-- \"jump [to] deck\" -- not implemented -->\n      <span class=\"caret\"></span>\n    </button>\n    <ul class=\"dropdown-menu pull-left\">\n    </ul>\n  </div>\n</div>";
    button_dom = $(markup);
    stay_in_view = _nav_menu_options["stay-in-view"];
    if ((stay_in_view != null) && !stay_in_view) {
      outer_el = document;
      button_dom.css('position', 'absolute');
    } else {
      outer_el = window;
    }
    left = false;
    x_pos = _nav_menu_options["x-position"];
    calculate_x = function() {
      var bw;
      if (x_pos === "left") {
        left = "5px";
      } else if (x_pos === "right") {
        button_dom.css("right", "5px");
        button_dom.find("ul.dropdown-menu").removeClass("pull-left").addClass("pull-right");
      } else if (x_pos === "middle") {
        bw = button_dom.find(_css_variables.selectors.deck_jump_scroll).width();
        left = ($(outer_el).width() - bw) / 2;
      } else {

      }
      if (left) {
        return button_dom.css("left", left);
      }
    };
    y_pos = _nav_menu_options["y-position"];
    top = "5px";
    calculate_top = function() {
      if (y_pos === "bottom") {
        top = ($(outer_el).height() - button_dom.height()) - 5;
        button_dom.addClass("dropup");
      } else if (y_pos === "middle") {
        top = ($(outer_el).height() - button_dom.height()) / 2;
      }
      return button_dom.css("top", top);
    };
    calculate_x();
    calculate_top();
    $("body").append(button_dom);
    calculate_top();
    calculate_x();
    return button_dom;
  };

  _create_jump_scroll = function(target_ul_selector, title_selector) {
    var $item_title_ddl, $title_items;
    if (_nav_menu == null) {
      _nav_menu = _create_nav_menu();
    }
    $item_title_ddl = $(target_ul_selector);
    $item_title_ddl.children().remove();
    $title_items = $(title_selector);
    if ($title_items.length === 0) {
      return;
    }
    return $title_items.each(function(index, item) {
      var $nav_item, title;
      title = $(item).data('title');
      $nav_item = $("<li><a href='#'>" + title + "</a></li>");
      $nav_item.on('click', function() {
        return _scrollToView($(item));
      });
      return $item_title_ddl.append($nav_item);
    });
  };

  _create_jump_scroll_card = function() {
    return _create_jump_scroll("" + _css_variables.selectors.card_jump_scroll + " ul", '.deckster-deck [data-title]');
  };

  _create_jump_scroll_deck = function() {
    return _create_jump_scroll("" + _css_variables.selectors.deck_jump_scroll + " ul", '.deckster-deck[data-title]');
  };

  window.Deckster = function(options) {
    var $deck, deckster, init, __$active_drag_card, __active_drag_card_drag_data, __card_data_by_id, __cards_by_id, __cards_needing_resolved_by_id, __cards_needing_resolved_in_order, __col_max, __deck, __default_options, __dominate_card_data, __event_callbacks, __events, __next_id, __row_max, __set_option, _add_back_card, _add_back_card_helper, _add_back_card_to_bottom, _add_card, _add_placeholders, _ajax, _apply_deck, _apply_transition, _bind_drag_controls, _clean_up_deck, _collapse_on_click, _does_fit_location, _expand_on_click, _fit_location, _force_card_to_position, _get_removed_card_li_tag, _identify_problem_cards, _loop_through_spaces, _mark_card_as_resolved, _move_card, _on, _placeholder_div, _ref1, _ref2, _ref3, _remove_card_from_deck, _remove_old_position, _remove_on_click, _resolve_card_position, _resolve_cards, _set_new_position, _should_remove_card_in_init;
    $deck = $(this);
    if (!$deck.hasClass(_css_variables.classes.deck)) {
      return console.log('Not a valid deck');
    }
    __default_options = {
      draggable: true,
      expandable: true,
      url_enabled: true,
      removable: true,
      droppable: true
    };
    options = $.extend({}, __default_options, options);
    /* 
    # Modify an option setting (with the config_option key) based on the
    # presence and value of a corresponding data- attribute (data_attr)
    # on the Deck DOM element
    */

    __set_option = function(data_attr, config_option) {
      var option;
      option = $deck.data(data_attr);
      if (option != null) {
        return options[config_option || data_attr] = option === true || option === 'true';
      }
    };
    __set_option('draggable');
    __set_option('expandable');
    __set_option('removable');
    __set_option('url-enabled', 'url_enabled');
    __set_option('droppable');
    /*
       Init Dragging options
    */

    options.animate = (_ref1 = options.animate) != null ? _ref1 : {};
    options.animate.properties = (_ref2 = options.animate.properties) != null ? _ref2 : {};
    options.animate.options = (_ref3 = options.animate.options) != null ? _ref3 : {};
    /*
    # Nav menu options (global)
    */

    $.extend(_nav_menu_options, options["scroll-helper"]);
    /*
      Deckster Base 
     --- Deckster Base Variables
    */

    __next_id = 1;
    __deck = {};
    __cards_by_id = {};
    __card_data_by_id = {};
    __col_max = 0;
    __row_max = 0;
    __cards_needing_resolved_in_order = [];
    __cards_needing_resolved_by_id = {};
    __dominate_card_data = void 0;
    /*
      Registered callbacks events.
    */

    __events = {
      card_added: 'card_added',
      inited: 'inited',
      card_expanded: 'card_expanded',
      card_collapsed: 'card_collapsed'
    };
    __event_callbacks = {};
    _on = function(event, callback) {
      if (__event_callbacks[event] == null) {
        __event_callbacks[event] = [];
      }
      return __event_callbacks[event].push(callback);
    };
    _ajax = function(options) {
      options = $.extend(true, {}, _ajax_default, options);
      return $.ajax(options);
    };
    _add_card = function($card, d) {
      var callback, _i, _len, _ref4, _results;
      if (d.col_span > __col_max) {
        throw 'Card is too wide';
      }
      _force_card_to_position($card, d, {
        row: d.row,
        col: d.col
      });
      _ref4 = __event_callbacks[__events.card_added] || [];
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($card, d) === false) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    _force_card_to_position = function($card, d, p) {
      if (p.col + (d.col_span - 1) > __col_max) {
        throw 'Card expands out of bounds';
      }
      _mark_card_as_resolved(d);
      __dominate_card_data = d;
      _identify_problem_cards();
      __deck = {};
      _loop_through_spaces(p.row, p.col, p.row + (d.row_span - 1), p.col + (d.col_span - 1), function(p2) {
        if (__deck[p2.row] == null) {
          __deck[p2.row] = {};
        }
        return __deck[p2.row][p2.col] = d.id;
      });
      return _resolve_cards();
    };
    _mark_card_as_resolved = function(d) {
      var i;
      if (__cards_needing_resolved_in_order.length > 0) {
        i = $.inArray(d.id, __cards_needing_resolved_in_order);
        if (i > -1) {
          __cards_needing_resolved_in_order.splice(i, 1);
          return delete __cards_needing_resolved_by_id[d.id];
        }
      }
    };
    _identify_problem_cards = function() {
      var col, cols, id, row, _results;
      _results = [];
      for (row in __deck) {
        cols = __deck[row];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (col in cols) {
            id = cols[col];
            if (!(id === void 0 || id === __dominate_card_data.id || (__cards_needing_resolved_by_id[id] != null))) {
              __cards_needing_resolved_by_id[id] = true;
              _results1.push(__cards_needing_resolved_in_order.push(id));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _loop_through_spaces = function(row_start, col_start, row_end, col_end, callback) {
      var col_i, p, r_value, row_i;
      row_i = row_start;
      while (row_i <= row_end) {
        col_i = col_start;
        while (col_i <= col_end) {
          p = {
            row: row_i,
            col: col_i
          };
          r_value = callback(p);
          if (r_value === false) {
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    _resolve_cards = function() {
      var $card, d, id, _results;
      _results = [];
      while (__cards_needing_resolved_in_order.length > 0) {
        id = __cards_needing_resolved_in_order[0];
        $card = __cards_by_id[id];
        d = __card_data_by_id[id];
        _resolve_card_position($card, d);
        _results.push(_mark_card_as_resolved(d));
      }
      return _results;
    };
    _resolve_card_position = function($card, d) {
      var can_go_here, col_i, row_i;
      row_i = 1;
      while (true) {
        if (__deck[row_i] == null) {
          __deck[row_i] = {};
        }
        col_i = 1;
        while (col_i <= (__col_max - d.col_span) + 1) {
          can_go_here = true;
          _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
            if (__deck[p2.row] == null) {
              __deck[p2.row] = {};
            }
            if (__deck[p2.row][p2.col]) {
              can_go_here = false;
              return false;
            }
          });
          if (can_go_here === true) {
            _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
              if (__deck[p2.row] == null) {
                __deck[p2.row] = {};
              }
              return __deck[p2.row][p2.col] = d.id;
            });
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    /*
      Used to transition cards to new positions on the deck. Typical scenario arises when a card is being dragged to a new position and adjacent cards need to be repositioned.
      Transition positions are looked up and cached locally.
    */

    _apply_transition = function($card, d) {
      var colStr, index, leftAnimate, myrules, mysheet, rowStr, rule, sheet, topAnimate, _base, _base1, _i, _j, _len, _len1, _ref4, _ref5;
      rowStr = _css_variables.selectors.card + "[data-row=\"" + d.row + "\"]";
      colStr = _css_variables.selectors.card + "[data-col=\"" + d.col + "\"]";
      _css_variables.dimensions = _css_variables.dimensions || {};
      leftAnimate = _css_variables.dimensions[colStr];
      topAnimate = _css_variables.dimensions[rowStr];
      if (!((leftAnimate != null) && (topAnimate != null))) {
        mysheet = null;
        _ref4 = document.styleSheets;
        for (index = _i = 0, _len = _ref4.length; _i < _len; index = ++_i) {
          sheet = _ref4[index];
          if (_css_variables.styleSheet === sheet.href.split("/").pop()) {
            mysheet = sheet;
            break;
          }
        }
        if (mysheet === null) {
          $card.attr('data-row', d.row);
          $card.attr('data-col', d.col);
          $card.css('opacity', '1');
          return;
        }
        myrules = (_ref5 = mysheet.cssRules) != null ? _ref5 : mysheet.rules;
        for (index = _j = 0, _len1 = myrules.length; _j < _len1; index = ++_j) {
          rule = myrules[index];
          if (rule.selectorText === rowStr) {
            topAnimate = rule.style.top;
            _css_variables.dimensions[rowStr] = topAnimate;
          } else if (rule.selectorText === colStr) {
            leftAnimate = rule.style.left;
            _css_variables.dimensions[colStr] = leftAnimate;
          }
        }
      }
      options.animate.properties.top = topAnimate;
      options.animate.properties.left = leftAnimate;
      if ((_base = options.animate.options).duration == null) {
        _base.duration = "slow";
      }
      if ((_base1 = options.animate.options).easing == null) {
        _base1.easing = "swing";
      }
      options.animate.options.always = function() {
        $card.attr('data-row', d.row);
        $card.attr('data-col', d.col);
        return $card.css('opacity', '1');
      };
      /*
      The animation becomes confusing and inaccurate when to many animations are attempted on the same card;Solution: Stop current and pending animations and start just this one.
      */

      return $card.stop(true, false).animate(options.animate.properties, options.animate.options);
    };
    _apply_deck = function() {
      var $card, applied_card_ids, col, cols, d, id, isDragging, row, row_max, row_max_value;
      row_max = 0;
      applied_card_ids = {};
      isDragging = true;
      for (row in __deck) {
        cols = __deck[row];
        for (col in cols) {
          id = cols[col];
          if (applied_card_ids[id] == null) {
            applied_card_ids[id] = true;
            $card = __cards_by_id[id];
            __card_data_by_id[id].row = parseInt(row);
            __card_data_by_id[id].col = parseInt(col);
            d = __card_data_by_id[id];
            $card.attr('data-card-id', id);
            if (isDragging && !$card.hasClass("draggable")) {
              _apply_transition($card, d);
            } else {
              $card.attr('data-row', d.row);
              $card.attr('data-col', d.col);
            }
            $card.attr('data-row-span', d.row_span);
            $card.attr('data-col-span', d.col_span);
            row_max_value = d.row + d.row_span - 1;
            if (row_max_value > __row_max) {
              __row_max = row_max_value;
            }
          }
        }
      }
      return $deck.attr('data-row-max', row_max);
    };
    /*
    # Initially, cards will be hidden if the 'data-hidden' attribute is true, or
    #   if the deck's 'remove-empty' attribute is true, and
    #   there is no card content, and
    #   there is no 'data-url' attribute
    */

    _should_remove_card_in_init = function($card, $deck) {
      return $card.data('hidden') === true || ($deck.data('remove-empty') === true && !$card.find(_css_variables.selectors.card_content).text().trim() && !$card.data('url'));
    };
    init = function() {
      var $deck_wrapper, $title_div, callback, cards, title, _i, _len, _ref4;
      __col_max = $deck.data('col-max');
      title = $deck.data("title");
      if (title != null) {
        $deck_wrapper = $("<div>");
        $deck.replaceWith($deck_wrapper);
        $title_div = $("<div class=\"deckster-title\">" + title + "</div>");
        $deck_wrapper.append($title_div, $deck);
      }
      cards = $deck.children(_css_variables.selectors.card);
      cards.each(function() {
        var $card, $cheight, $theight, d;
        $card = $(this);
        if (_should_remove_card_in_init($card, $deck)) {
          $card.remove();
        } else {
          d = {
            id: __next_id++,
            row: parseInt($card.attr('data-row')),
            col: parseInt($card.attr('data-col')),
            row_span: parseInt($card.attr('data-row-span')),
            col_span: parseInt($card.attr('data-col-span'))
          };
          __cards_by_id[d.id] = $card;
          __card_data_by_id[d.id] = d;
          _add_card($card, d);
        }
        $cheight = $(this).height();
        $theight = $('.deckster-card-title', this).height() + 40;
        $('.deckster-card-title', this).css('margin-top', -$theight);
        return $(this).css('padding-top', $theight);
      });
      _apply_deck();
      cards.append("<div class='" + _css_variables.classes.controls + "'></div>");
      _ref4 = __event_callbacks[__events.inited] || [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($deck) === false) {
          break;
        }
      }
      _create_jump_scroll_card(0xDCC0FFEEBAD);
      return _create_jump_scroll_deck(0xDEADBEEF);
    };
    if (options['draggable'] && options['draggable'] === true) {
      __$active_drag_card = void 0;
      __active_drag_card_drag_data = void 0;
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a class='" + _css_variables.classes.drag_handle + " control drag'></a>";
        return $deck.find(_css_variables.selectors.controls).append(controls);
      });
      _on(__events.inited, function($deck) {
        return _bind_drag_controls(this);
      });
      _bind_drag_controls = function(deck) {
        $deck.find(_css_variables.selectors.drag_handle).on("mousedown", function(e) {
          var $drag_handle;
          $drag_handle = $(this);
          __$active_drag_card = $drag_handle.parents(_css_variables.selectors.card);
          __$active_drag_card.addClass('draggable');
          __$active_drag_card.css('z-index', 1000);
          __active_drag_card_drag_data = {
            height: __$active_drag_card.outerHeight(),
            width: __$active_drag_card.outerWidth(),
            pos_y: __$active_drag_card.offset().top + __$active_drag_card.outerHeight() - e.pageY,
            pos_x: __$active_drag_card.offset().left + __$active_drag_card.outerWidth() - e.pageX
          };
          __active_drag_card_drag_data['original_top'] = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
          __active_drag_card_drag_data['original_left'] = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
          return e.preventDefault();
        });
        $deck.on('mousemove', function(e) {
          var messages, new_left, new_top, original_left, original_top;
          if (__$active_drag_card != null) {
            new_top = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
            new_left = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
            original_left = __active_drag_card_drag_data['original_left'];
            original_top = __active_drag_card_drag_data['original_top'];
            messages = [];
            if (new_top - original_top < -200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] - 200;
              _move_card(__$active_drag_card, "up");
              messages.push('UP');
            }
            if (new_top - original_top > 200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] + 200;
              _move_card(__$active_drag_card, "down");
              messages.push('DOWN');
            }
            if (new_left - original_left < -300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] - 300;
              _move_card(__$active_drag_card, "left");
              messages.push('LEFT');
            }
            if (new_left - original_left > 300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] + 300;
              _move_card(__$active_drag_card, "right");
              messages.push('RIGHT');
            }
            if (messages.length > 0) {
              console.log(messages.join(' '));
            }
            return __$active_drag_card.offset({
              top: new_top,
              left: new_left
            });
          }
        });
        return $deck.on('mouseup', function(e) {
          if (__$active_drag_card != null) {
            __$active_drag_card.removeClass('draggable');
            __$active_drag_card.css('top', '');
            __$active_drag_card.css('left', '');
            __$active_drag_card.css('z-index', '');
            __$active_drag_card = void 0;
            return __active_drag_card_drag_data = void 0;
          }
        });
      };
      _move_card = function($card, direction) {
        var d, id;
        id = $card.data('card-id');
        d = __card_data_by_id[id];
        switch (direction) {
          case 'left':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col - 1
            });
            break;
          case 'right':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col + 1
            });
            break;
          case 'up':
            _force_card_to_position($card, d, {
              row: d.row - 1,
              col: d.col
            });
            break;
          case 'down':
            _force_card_to_position($card, d, {
              row: d.row + 1,
              col: d.col
            });
        }
        return _apply_deck();
      };
    }
    if (options['expandable'] && options['expandable'] === true) {
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a class='" + _css_variables.classes.expand_handle + " control expand'></a>\n<a class='" + _css_variables.classes.collapse_handle + " control collapse' style='display:none;'></a>";
        $deck.find(_css_variables.selectors.controls).append(controls);
        $deck.find(_css_variables.selectors.expand_handle).click(function() {
          return _expand_on_click(this);
        });
        return $deck.find(_css_variables.selectors.collapse_handle).click(function() {
          return _collapse_on_click(this);
        });
      });
      _expand_on_click = function(element) {
        var $card, $expand_handle, callback, d, expandColTo, expandRowTo, id, _i, _len, _ref4, _results;
        $expand_handle = $(element);
        $card = $expand_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        console.log([
          'Expand <<<', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        $card.attr('data-original-col', d.col);
        $card.attr('data-original-row-span', d.row_span);
        $card.attr('data-original-col-span', d.col_span);
        if ($card.data("col-expand") != null) {
          expandColTo = parseInt($card.data("col-expand"));
          expandColTo = expandColTo > __col_max ? __col_max : expandColTo;
        }
        expandColTo = (expandColTo != null) && expandColTo > 0 ? expandColTo : d.col_span;
        if ($card.data("row-expand") != null) {
          expandRowTo = parseInt($card.data("row-expand"));
        }
        expandRowTo = (expandRowTo != null) && expandRowTo > 0 ? expandRowTo : d.row_span;
        d['row_span'] = expandRowTo;
        d['col'] = (expandColTo - 1) + d.col <= __col_max ? d.col : 1;
        d['col_span'] = expandColTo;
        if (d.col_span === $card.data('original-col-span') && d.row_span === $card.data('original-row-span')) {
          return;
        }
        console.log([
          'Expand >>>', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $expand_handle.hide();
        $expand_handle.siblings(_css_variables.selectors.collapse_handle).show();
        _ref4 = __event_callbacks[__events.card_expanded] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _collapse_on_click = function(element) {
        var $card, $collapse_handle, callback, d, id, _i, _len, _ref4, _results;
        $collapse_handle = $(element);
        $card = $collapse_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        d.col = parseInt($card.attr('data-original-col'));
        d.row_span = parseInt($card.attr('data-original-row-span'));
        d.col_span = parseInt($card.attr('data-original-col-span'));
        $card.attr('data-original-col', '');
        $card.attr('data-original-row-span', '');
        $card.attr('data-original-col-span', '');
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $collapse_handle.hide();
        $collapse_handle.siblings(_css_variables.selectors.expand_handle).show();
        _clean_up_deck();
        _ref4 = __event_callbacks[__events.card_collapsed] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _on(__events.inited, function() {
        return $(_css_variables.selectors.deck + ":not(" + _css_variables.selector_functions.deck_expanded(false) + ")").each(function(index) {
          $deck = $(this);
          return $deck.find(_css_variables.selectors.card + ":not(" + _css_variables.selector_functions.card_expanded(false) + ")").each(function(index) {
            return $(this).find(_css_variables.selectors.expand_handle).trigger("click");
          });
        });
      });
      _on(__events.card_expanded, function($deck, $card) {
        var ajaxOptions, cardActions, cardId, deckId, _ref4;
        deckId = (_ref4 = $deck.data("deck-id")) != null ? _ref4 : 1;
        cardId = $card.data("card-id");
        if ((options["card-actions"] != null) && (options["card-actions"]["deck-" + deckId] != null) && (options["card-actions"]["deck-" + deckId]["card-" + cardId] != null)) {
          cardActions = options["card-actions"]["deck-" + deckId]["card-" + cardId];
          if (cardActions["card-expanded"] != null) {
            ajaxOptions = cardActions["card-expanded"]($card, $card.find(_css_variables.selectors.card_content));
            if (ajaxOptions != null) {
              /*
                 Abort any requests that are currently on-going.
              */

              if (_ajax_requests[deckId] && _ajax_requests[deckId][cardId]) {
                _ajax_requests[deckId][cardId].abort();
                delete _ajax_requests[deckId][cardId];
              }
              /*
                 Send the ajax request after any card animation has finished (Typically when a card is expanded its size will be changed.) For example, trying to animate and load content into the card makes both operations laggy and detract from the user experience.
              */

              return $card.queue().push(function() {
                return _ajax(ajaxOptions);
              });
            }
          }
        }
      });
      _on(__events.card_collapsed, function($deck, $card) {
        var ajaxOptions, cardActions, cardId, deckId, _ref4;
        deckId = (_ref4 = $deck.data("deck-id")) != null ? _ref4 : 1;
        cardId = $card.data("card-id");
        if ((options["card-actions"] != null) && (options["card-actions"]["deck-" + deckId] != null) && (options["card-actions"]["deck-" + deckId]["card-" + cardId] != null)) {
          cardActions = options["card-actions"]["deck-" + deckId]["card-" + cardId];
          if (cardActions["card-collapsed"] != null) {
            ajaxOptions = cardActions["card-collapsed"]($card, $card.find(_css_variables.selectors.card_content));
            if (ajaxOptions != null) {
              return $card.queue().push(function() {
                return _ajax(ajaxOptions);
              });
            }
          }
        }
      });
    }
    /*
      Setting url_enabled to true allows ajax requests to run.
    */

    if (options['url_enabled'] === true) {
      _on(__events.card_added, function($card, d) {
        var ajax_options, cardId, deckId, _ref4;
        if ($card.data("url") != null) {
          ajax_options = {
            url: $card.data("url"),
            type: $card.data("url-method") != null ? $card.data("url-method") : "GET",
            context: $card,
            success: function(data, status, response) {
              var $controls, $title, divText;
              if (!!data.trim()) {
                $controls = this.find(_css_variables.selectors.controls).clone(true);
                $title = this.find(_css_variables.selectors.card_title);
                this.html("");
                this.append($title);
                this.append($controls);
                return this.append('<div class="content">' + data + '</div>');
              } else {
                divText = this.find(_css_variables.selectors.card_content).text();
                if (!divText.trim() && $deck.data('remove-empty') === true) {
                  _create_jump_scroll_card();
                  this.remove();
                  return _remove_card_from_deck(this);
                }
              }
            }
          };
          deckId = (_ref4 = $card.closest(_css_variables.selectors.deck).data("deck-id")) != null ? _ref4 : 1;
          cardId = d.id;
          /*
           Keep track of requests incase we need to abort them.
          */

          _ajax_requests[deckId] = _ajax_requests[deckId] || {};
          return _ajax_requests[deckId][cardId] = _ajax(ajax_options);
        }
      });
    }
    /*
      Droppable Helper Methods:
    */

    _placeholder_div = function($card, _d, settings) {
      var $placeholder, height, width;
      width = $card.outerWidth();
      height = $card.outerHeight();
      $placeholder = $("<div>").addClass("placeholders").addClass(_css_variables.selectors.card.substring(1)).attr("data-col", _d["col"]).attr("data-row", _d["row"]).attr("data-col-span", _d.col_span).attr("data-row-span", _d.row_span).css("background-color", "rgb(" + settings.r + "," + settings.g + "," + settings.b + ")").css("z-index", settings.zIndex);
      $card.closest(_css_variables.selectors.deck).append($placeholder);
      $placeholder.click(function(action) {
        var $selectedCard;
        _remove_old_position($card, __card_data_by_id[_d.id]);
        $selectedCard = $(action.currentTarget);
        __card_data_by_id[_d.id] = _d;
        _set_new_position($card, _d);
        _apply_transition($card, _d);
        return $card.find(_css_variables.selectors.droppable).trigger("click");
      });
      $placeholder.mouseenter(function(action) {
        $(this).data("prev-z-index", $(this).css("z-index"));
        return $(this).css("z-index", 1000);
      });
      $placeholder.mouseleave(function(action) {
        return $(this).css("z-index", $(this).data("prev-z-index"));
      });
      return $card;
    };
    _remove_old_position = function($card, d) {
      var col_end, col_remove, row_end, row_remove, _i, _j, _ref4, _ref5;
      row_end = d.row + d.row_span - 1;
      col_end = d.col + d.col_span - 1;
      for (row_remove = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_remove = _ref4 <= row_end ? ++_i : --_i) {
        for (col_remove = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_remove = _ref5 <= col_end ? ++_j : --_j) {
          delete __deck[row_remove][col_remove];
        }
      }
      return true;
    };
    _set_new_position = function($card, d) {
      var col_add, col_end, row_add, row_end, _i, _j, _ref4, _ref5;
      row_end = d.row_span + d.row - 1;
      col_end = d.col_span + d.col - 1;
      for (row_add = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_add = _ref4 <= row_end ? ++_i : --_i) {
        if (!__deck[row_add]) {
          __deck[row_add] = {};
        }
        for (col_add = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_add = _ref5 <= col_end ? ++_j : --_j) {
          __deck[row_add][col_add] = d.id;
        }
      }
      if (row_end > __row_max) {
        __row_max = row_end;
      }
      _clean_up_deck();
      return true;
    };
    _clean_up_deck = function() {
      var row_subtractor, _results;
      row_subtractor = __row_max;
      _results = [];
      while (row_subtractor > 0) {
        if ($.isEmptyObject(__deck[row_subtractor])) {
          delete __deck[row_subtractor];
          if (__row_max === row_subtractor) {
            __row_max -= 1;
          }
        }
        _results.push(row_subtractor -= 1);
      }
      return _results;
    };
    _fit_location = function(row, col, d) {
      var col_end, col_test, row_end, row_test, _i, _j;
      row_end = d.row_span + row - 1;
      col_end = d.col_span + col - 1;
      if (col_end > __col_max) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (__deck[row_test] && __deck[row_test][col_test]) {
            return false;
          }
        }
      }
      return true;
    };
    _add_placeholders = function($card, d) {
      var b, col, g, new_d, r, row, zIndex, _i, _j, _ref4;
      zIndex = 1;
      r = 0;
      g = 25;
      b = 50;
      for (row = _i = 1, _ref4 = __row_max + 1; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; row = 1 <= _ref4 ? ++_i : --_i) {
        for (col = _j = 1; 1 <= __col_max ? _j <= __col_max : _j >= __col_max; col = 1 <= __col_max ? ++_j : --_j) {
          if (_fit_location(row, col, d)) {
            new_d = {
              "id": d.id,
              "row": row,
              "col": col,
              "row_span": d.row_span,
              "col_span": d.col_span
            };
            console.log("new_d", new_d);
            _placeholder_div($card, new_d, {
              "zIndez": zIndex,
              "r": r,
              "g": g,
              "b": b
            });
            zIndex += 1;
            r = (r + 0) % 200;
            g = (g + 50) % 150;
            b = (b + 50) % 250;
          }
        }
      }
      return -1;
    };
    /* 
      If set to true, cards can be picked up and dropped to a new spot on the deck without disturbing the positions of any other card.
      :Droppable Helper Methods End.
    */

    if (options.droppable === true) {
      _on(__events.inited, function($card, d) {
        var $controls, $droppable;
        $controls = $card.find(_css_variables.selectors.controls);
        $droppable = $("<a></a>").addClass(_css_variables.selectors.droppable.substring(1) + ' control droppable1');
        $droppable.click(function(element) {
          var $drop_handle, id;
          $drop_handle = $(element.currentTarget);
          if (!$drop_handle.hasClass("cancel")) {
            $card = $drop_handle.closest(_css_variables.selectors.card);
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(":visible").addClass("hider").hide();
            $drop_handle.show();
            $drop_handle.addClass("cancel");
            id = parseInt($card.attr('data-card-id'));
            d = __card_data_by_id[id];
            return _add_placeholders($card, d);
          } else {
            $drop_handle.removeClass("cancel");
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(".hider").show().removeClass("hider");
            return $deck.find(_css_variables.selectors.placeholders).remove();
          }
        });
        return $controls.append($droppable);
      });
    }
    if (true) {
      _on(__events.card_added, function($card, d) {
        var $title_div, title;
        title = $card.data("title");
        if (!((title != null) && !$card.find(_css_variables.selectors.card_title).text())) {
          return;
        }
        $title_div = $('<div>').text(title).addClass(_css_variables.classes.card_title);
        return $card.prepend($title_div);
      });
    }
    if (options['removable'] && options['removable'] === true) {
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a class='" + _css_variables.classes.remove_handle + " control remove'></a>";
        $deck.find(_css_variables.selectors.controls).append(controls);
        return $deck.find(_css_variables.selectors.remove_handle).click(function() {
          return _remove_on_click(this);
        });
      });
      _remove_on_click = function(element) {
        var $card, $remove_handle, dropdown, id, removed_dropdown_div, titleText;
        $remove_handle = $(element);
        $card = $remove_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        titleText = $card.find(_css_variables.selectors.card_title).text();
        if (!titleText) {
          titleText = $card.find(_css_variables.selectors.card_content).text().substring(0, 15);
        }
        dropdown = $deck.parent().find(_css_variables.selectors.removed_dropdown);
        if (dropdown.val() != null) {
          dropdown.find('ul').append(_get_removed_card_li_tag(id, titleText)).appendTo(dropdown);
        } else {
          removed_dropdown_div = ("          <div class='btn-group " + _css_variables.classes.removed_dropdown + "'>            <button type='button' class='btn btn-default dropdown-toggle' data-toggle='dropdown'>              Removed Cards              <span class='caret'></span>            </button>            <ul class='dropdown-menu removed-cards pull-left'>              ") + _get_removed_card_li_tag(id, titleText) + "             </ul>          </div>          ";
          $deck.parent().prepend(removed_dropdown_div);
          dropdown = $deck.parent().find(_css_variables.selectors.removed_dropdown);
        }
        dropdown.find('#' + _css_variables.classes.removed_card_button + '-' + id).click(function() {
          return _add_back_card(id);
        });
        dropdown.find('#' + _css_variables.classes.add_card_to_bottom_button + '-' + id).click(function() {
          return _add_back_card_to_bottom(id);
        });
        _remove_card_from_deck($card);
        $card.remove();
        _create_jump_scroll_card();
        return _apply_deck();
      };
      /*
      # Removes the card from the __deck variable so that it doesn't take up space once removed
      */

      _remove_card_from_deck = function($card) {
        var cardId, col, cols, id, row;
        cardId = parseInt($card.attr('data-card-id'));
        for (row in __deck) {
          cols = __deck[row];
          for (col in cols) {
            id = cols[col];
            if (cardId === id) {
              delete __deck[row][col];
            }
          }
        }
        return void 0;
      };
      /*
      # Returns the <li> tag for this card, to be shown within the 'Removed Card' dropdown.
      # It displays the card title (or the first 15 characters of the card content, if no title),
      #   and an 'Add' button.
      */

      _get_removed_card_li_tag = function(id, titleText) {
        return ("<li id='" + _css_variables.classes.removed_card_li + "-") + id + ("' class='" + _css_variables.classes.removed_card_li + "'>") + titleText + ("<a id='" + _css_variables.classes.removed_card_button + "-") + id + ("' ><img src='./public/images/plus.png'                  class='" + _css_variables.classes.removed_card_button + "' ></a>") + ("<button id='" + _css_variables.classes.add_card_to_bottom_button + "-") + id + "' class='btn control add'>Add to bottom</button>" + "</li>";
      };
      /*
      # This is the callback when the 'Add' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card = function(cardId) {
        var $card, d;
        if (cardId == null) {
          return;
        }
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        return _add_back_card_helper(cardId, $card, d);
      };
      /*
      # This is the callback when the 'Add to bottom ' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card_to_bottom = function(cardId) {
        var $card, can_fit_in_last_row, col, d, _i;
        if (cardId == null) {
          return;
        }
        console.log("__row_max: " + __row_max);
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        can_fit_in_last_row = false;
        for (col = _i = 1; _i <= __col_max; col = _i += 1) {
          if (_does_fit_location(__row_max, col, d)) {
            can_fit_in_last_row = true;
            console.log("fits in max row: __row_max, col: " + __row_max, col);
            break;
          } else {
            console.log("doesn't fit in max row: __row_max, col: " + __row_max, col);
          }
        }
        if (can_fit_in_last_row) {
          d.row = __row_max;
          d.col = col;
        } else {
          d.row = __row_max + 1;
          d.col = 1;
        }
        return _add_back_card_helper(cardId, $card, d);
      };
      _add_back_card_helper = function(cardId, $card, d) {
        var dropdown;
        $deck.append($card);
        _add_card($card, d);
        _apply_deck();
        $card.find(_css_variables.selectors.remove_handle).click(function() {
          return _remove_on_click(this);
        });
        $card.find(_css_variables.selectors.expand_handle).click(function() {
          return _expand_on_click(this);
        });
        $card.find(_css_variables.selectors.collapse_handle).click(function() {
          return _collapse_on_click(this);
        });
        _bind_drag_controls($card);
        _create_jump_scroll_card();
        $deck.parent().find('#' + _css_variables.classes.removed_card_li + '-' + cardId).remove();
        dropdown = $deck.parent().find(_css_variables.selectors.removed_dropdown);
        if (dropdown.find('ul').children().size() === 0) {
          return dropdown.remove();
        }
      };
    }
    _does_fit_location = function(row, col, d) {
      var col_end, col_test, row_end, row_test, _i, _j;
      row_end = d.row_span + row;
      col_end = d.col_span + col;
      if (col_end - 1 > __col_max) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (__deck[row_test] && __deck[row_test][col_test]) {
            return false;
          }
        }
      }
      return true;
    };
    init();
    return deckster = {
      deck: __deck,
      on: _on,
      events: __events
    };
  };

  $ = jQuery;

  $.fn.deckster = window.Deckster;
}).call(this);
