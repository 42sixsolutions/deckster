// Generated by CoffeeScript 1.6.3
(function() {
  var $, selector, sym, __events, _ajax_default, _ajax_requests, _create_jump_scroll, _create_jump_scroll_card, _create_jump_scroll_deck, _create_nav_menu, _css_variables, _document, _nav_menu, _nav_menu_options, _ref, _scrollToView;

  _css_variables = {
    selectors: {
      deck: '.deckster-deck',
      card: '.deckster-card',
      card_title: '.deckster-card-title',
      controls: '.deckster-controls',
      drag_handle: '.deckster-drag-handle',
      expand_handle: '.deckster-expand-handle',
      collapse_handle: '.deckster-collapse-handle',
      card_jump_scroll: '.deckster-card-jump-scroll',
      deck_jump_scroll: '.deckster-deck-jump-scroll',
      remove_handle: '.deckster-remove-handle',
      removed_dropdown: '.deckster-removed-dropdown',
      removed_card_li: '.deckster-removed-card-li',
      removed_card_button: '.deckster-removed-card-button',
      add_card_to_bottom_button: '.deckster-add-card-to-bottom-button',
      card_content: '.content',
      placeholders: '.placeholders',
      droppable: '.droppable',
      deck_title: '.deckster-title',
      deck_container: '.deckster-deck-container',
      deck_controls: '.deck-controls',
      placeholders: '.placeholder',
      drag_mod_handle: '.deckster-drag-mod-handle'
    },
    selector_functions: {
      card_expanded: function(option) {
        return '[data-expanded=' + option + ']';
      },
      deck_expanded: function(option) {
        return '[data-cards-expanded=' + option + ']';
      }
    },
    classes: {},
    dimensions: {},
    styleSheet: "deckster.css",
    chars_to_display: 20,
    buffer: "b"
  };

  _ref = _css_variables.selectors;
  for (sym in _ref) {
    selector = _ref[sym];
    _css_variables.classes[sym] = selector.slice(1);
  }

  __events = {
    card_added: 'card_added',
    inited: 'inited',
    card_expanded: 'card_expanded',
    card_collapsed: 'card_collapsed',
    card_moved: 'card_moved'
  };

  _scrollToView = function($el) {
    var offset;
    offset = $el.offset();
    offset.top -= 20;
    offset.left -= 20;
    return $('html, body').animate({
      scrollTop: offset.top,
      scrollLeft: offset.left
    });
  };

  _nav_menu = null;

  _nav_menu_options = {};

  /*
  # Creates the Bootstrap-based Navigation menu/Jump Scroll bar/Scroll helper from HTML,
  # applies config options, places it in the DOM tree and returns the new element
  */


  _create_nav_menu = function() {
    var button_dom, markup;
    markup = "<div class=\"btn-group " + _css_variables.classes.deck_jump_scroll + "\">\n<span class=\"dropdown-toggle control jump-deck\" data-toggle=\"dropdown\"></span>\n<ul class=\"dropdown-menu pull-right\"></ul>\n</div>\n</div>";
    button_dom = $(markup);
    /* Let the Design/Developer place this in CSS
    stay_in_view = _nav_menu_options["stay-in-view"]
    if stay_in_view? and not stay_in_view
        outer_el = document
        button_dom.css 'position', 'absolute'
    else
        outer_el = window # outer_el is what we're going to measure to place the button bar
    
    left = false
    x_pos =_nav_menu_options["x-position"]
    calculate_x = () ->
        if x_pos is "left"
            left = "5px"
        else if x_pos is "right"
            button_dom.css "right", "5px"
            button_dom.find("ul.dropdown-menu")
                .removeClass("pull-left")
                .addClass("pull-right")
        else if x_pos is "middle"
            bw = button_dom.find(_css_variables.selectors.deck_jump_scroll)
                    .width()
            left = ($(outer_el).width() - bw) / 2
        else
        if left
            button_dom.css "left", left
    
    y_pos = _nav_menu_options["y-position"]
    top = "5px"
    calculate_top = () ->
        if y_pos is "bottom"
            top = ($(outer_el).height() - button_dom.height()) - 5
            button_dom.addClass("dropup")
        else if y_pos is "middle"
            top = ($(outer_el).height() - button_dom.height()) / 2
        button_dom.css "top", top
    
    # Apply calculate functions once to get approximate positioning
    calculate_x()
    calculate_top()
    */

    $("body").append(button_dom);
    /*
    # Re-calculate with button size known
    calculate_top()
    calculate_x()
    */

    return button_dom;
  };

  _create_jump_scroll = function(target_ul_selector, title_selector, classId) {
    var $item_title_ddl, $title_items;
    if (_nav_menu == null) {
      _nav_menu = _create_nav_menu();
    }
    $item_title_ddl = $(target_ul_selector);
    $item_title_ddl.children().remove();
    $title_items = $(title_selector);
    if ($title_items.length === 0) {
      return;
    }
    return $title_items.each(function(index, item) {
      var $nav_item, elementId, title, _ref1;
      title = $(item).data('title');
      elementId = (_ref1 = $(item).attr("data-card-id")) != null ? _ref1 : $(item).attr("id");
      $nav_item = $("<li id='" + (classId + "-" + elementId) + "'><a href='#'>" + title + "</a></li>");
      $nav_item.on('click', function() {
        return _scrollToView($(item));
      });
      return $item_title_ddl.append($nav_item);
    });
  };

  _create_jump_scroll_card = function($deck) {
    return _create_jump_scroll("#" + $deck.attr("id") + "-nav" + " ul", "#" + $deck.attr("id") + '.deckster-deck [data-title]', _css_variables.classes.card_jump_scroll);
  };

  _create_jump_scroll_deck = function() {
    return _create_jump_scroll("" + _css_variables.selectors.deck_jump_scroll + " ul", '.deckster-deck[data-title]', _css_variables.classes.deck_jump_scroll);
  };

  /*
    Default Ajax options, some options are typically overwritten.
  */


  _ajax_default = {
    success: function(data, status, response) {
      return console.log("Success: " + status);
    },
    error: function(response, status, exception) {
      return console.log("Status: " + status + " Error: " + exception);
    },
    timeout: 3000,
    type: 'GET',
    async: true
  };

  /*
    Used to keep track of ajax requests. Typically stored as _ajax_requests[deckId][cardId] = $.ajax(...)
  */


  _ajax_requests = {};

  jQuery.deckster = function(options) {
    console.log("Registering global callbacks");
    return _document.__deck_mgr = options;
  };

  window.Deckster = function(options) {
    var $deck, deckster, height_max_limit, height_min_limit, init, set_up_expansion, width_max_limit, width_min_limit, __$active_drag_card, __$active_dragging_card, __$active_dragging_placeholder, __active_drag_card_drag_data, __active_dragging_data, __card_data_by_id, __cards_by_id, __cards_needing_resolved_by_id, __cards_needing_resolved_in_order, __col_max, __col_threshold_max, __col_threshold_min, __deck, __default_options, __dominate_card_data, __event_callbacks, __next_id, __row_max, __row_threshold_max, __row_threshold_min, __set_option, _add_back_card, _add_back_card_helper, _add_back_card_to_bottom, _add_card, _add_card_to_jump, _add_placeholders, _adjust_adjacent_decks, _adjust_conflicts, _ajax, _apply_deck, _apply_transition, _bind_drag_controls, _can_move_up, _card_changed, _clean_up_deck, _click_to_collapse, _click_to_expand, _collapse_card, _collapse_on_click, _create_box, _delete_card_from_removed, _does_fit_location, _expand_card, _expand_on_click, _find_conflicting_cards, _find_expansion_size, _fit_location, _force_card_to_position, _get_removed_card_li_tag, _height_check, _identify_intersecting_cards, _identify_problem_cards, _init_card_add_remove, _init_card_scroll, _init_deck_header, _init_deck_wrapper, _init_drag_expand, _init_drag_expand_callbacks, _init_persistence, _layout_check, _limit_reached, _loadRemoteDeck, _localMgr, _loop_through_spaces, _mark_card_as_resolved, _move_card, _move_to_open_position, _move_up, _move_up_cardwise, _on, _placeholder_callbacks, _placeholder_div, _ref1, _ref2, _ref3, _remove_card_from_deck, _remove_old_position, _remove_on_click, _reset_deck, _resolve_card_position, _resolve_cards, _saveDeckRemotly, _set_new_position, _should_remove_card_in_init, _width_check;
    $deck = $(this);
    if (!$deck.hasClass(_css_variables.classes.deck)) {
      return console.log('Not a valid deck');
    }
    __event_callbacks = {};
    __default_options = {
      draggable: true,
      expandable: true,
      url_enabled: true,
      removable: true,
      droppable: true,
      persist: true,
      drag_expand: true
    };
    options = $.extend({}, __default_options, options);
    /*
    # Modify an option setting (with the config_option key) based on the
    # presence and value of a corresponding data- attribute (data_attr)
    # on the Deck DOM element
    */

    __set_option = function(data_attr, config_option) {
      var option;
      option = $deck.data(data_attr);
      if (option != null) {
        return options[config_option || data_attr] = option === true || option === 'true';
      }
    };
    __set_option('draggable');
    __set_option('expandable');
    __set_option('removable');
    __set_option('url-enabled', 'url_enabled');
    __set_option('droppable');
    __set_option('drag_expand');
    /*
       Init Dragging options
    */

    options.animate = (_ref1 = options.animate) != null ? _ref1 : {};
    options.animate.properties = (_ref2 = options.animate.properties) != null ? _ref2 : {};
    options.animate.options = (_ref3 = options.animate.options) != null ? _ref3 : {};
    /*
    # Nav menu options (global)
    */

    $.extend(_nav_menu_options, options["scroll-helper"]);
    __next_id = 1;
    __deck = {};
    __cards_by_id = {};
    __card_data_by_id = {};
    __col_max = 0;
    __row_max = 0;
    __cards_needing_resolved_in_order = [];
    __cards_needing_resolved_by_id = {};
    __dominate_card_data = void 0;
    _on = function(event, callback) {
      if (__event_callbacks[event] == null) {
        __event_callbacks[event] = [];
      }
      return __event_callbacks[event].push(callback);
    };
    _add_card = function($card, d, remainStatic) {
      var callback, retain_callbacks, _i, _len, _ref4;
      if (d.col_span > __col_max) {
        throw 'Card is too wide';
      }
      /* Note:
        * data-skip-force: cards that are being loaded from a saved deck and don't need to be positioned via
        _force_card_to_position(..)
        * data-is-removed: cards that have been removed and don't need to be position/added to __deck
      */

      if (($card.attr("data-skip-force") === "true" && $card.attr("data-is-removed") !== "true") || remainStatic) {
        /* 
          if loading a saved deck, just set the new position in __deck and run callbacks so cards don't
            get repositioned with _force_card_to_position(..).
        */

        _set_new_position($card, d);
      } else if ($card.attr("data-skip-force") !== "true" && $card.attr("data-is-removed") !== "true") {
        /* If we're not loading a saved deck, run this function (per usual)*/

        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
      }
      /* else skip adding card to __deck and run callbacks*/

      /* Removed Cards: Since these cards will not be added to __deck 
          and hence its 'data-card-id' will not be updated/initialized in _apply_deck(),
          I will need to update its data-card-id here
      */

      if ($card.attr("data-is-removed") === "true") {
        $card.attr('data-card-id', d.id);
      }
      retain_callbacks = [];
      _ref4 = __event_callbacks[__events.card_added] || [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($card, d) !== false) {
          retain_callbacks.push(callback);
        }
      }
      return __event_callbacks[__events.card_added] = retain_callbacks;
    };
    _force_card_to_position = function($card, d, p) {
      if (p.col + (d.col_span - 1) > __col_max) {
        throw 'Card expands out of bounds';
      }
      _mark_card_as_resolved(d);
      __dominate_card_data = d;
      _identify_problem_cards();
      __deck = {};
      _document.__deck_mgr = _document.__deck_mgr || {};
      _loop_through_spaces(p.row, p.col, p.row + (d.row_span - 1), p.col + (d.col_span - 1), function(p2) {
        if (__deck[p2.row] == null) {
          __deck[p2.row] = {};
        }
        return __deck[p2.row][p2.col] = d.id;
      });
      return _resolve_cards();
    };
    _mark_card_as_resolved = function(d) {
      var i;
      if (__cards_needing_resolved_in_order.length > 0) {
        i = $.inArray(d.id, __cards_needing_resolved_in_order);
        if (i > -1) {
          __cards_needing_resolved_in_order.splice(i, 1);
          return delete __cards_needing_resolved_by_id[d.id];
        }
      }
    };
    _identify_problem_cards = function() {
      var col, cols, id, row, _results;
      _results = [];
      for (row in __deck) {
        cols = __deck[row];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (col in cols) {
            id = cols[col];
            if (!(id === void 0 || id === __dominate_card_data.id || (__cards_needing_resolved_by_id[id] != null))) {
              __cards_needing_resolved_by_id[id] = true;
              _results1.push(__cards_needing_resolved_in_order.push(id));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _loop_through_spaces = function(row_start, col_start, row_end, col_end, callback) {
      var col_i, p, r_value, row_i;
      row_i = row_start;
      while (row_i <= row_end) {
        col_i = col_start;
        while (col_i <= col_end) {
          p = {
            row: row_i,
            col: col_i
          };
          r_value = callback(p);
          if (r_value === false) {
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    _resolve_cards = function() {
      var $card, d, id, _results;
      _results = [];
      while (__cards_needing_resolved_in_order.length > 0) {
        id = __cards_needing_resolved_in_order[0];
        $card = __cards_by_id[id];
        d = __card_data_by_id[id];
        _resolve_card_position($card, d);
        _results.push(_mark_card_as_resolved(d));
      }
      return _results;
    };
    _resolve_card_position = function($card, d) {
      var can_go_here, col_i, row_i;
      row_i = 1;
      while (true) {
        if (__deck[row_i] == null) {
          __deck[row_i] = {};
        }
        col_i = 1;
        while (col_i <= (__col_max - d.col_span) + 1) {
          can_go_here = true;
          _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
            if (__deck[p2.row] == null) {
              __deck[p2.row] = {};
            }
            if (__deck[p2.row][p2.col]) {
              can_go_here = false;
              return false;
            }
          });
          if (can_go_here === true) {
            _loop_through_spaces(row_i, col_i, row_i + (d.row_span - 1), col_i + (d.col_span - 1), function(p2) {
              if (__deck[p2.row] == null) {
                __deck[p2.row] = {};
              }
              return __deck[p2.row][p2.col] = d.id;
            });
            return;
          }
          col_i++;
        }
        row_i++;
      }
    };
    /*
      Used to transition cards to new positions on the deck. Typical scenario arises when a card is being dragged to a new position and adjacent cards need to be repositioned.
      Transition positions are looked up and cached locally.
    */

    _apply_transition = function($card, d) {
      var colStr, index, leftAnimate, myrules, mysheet, rowStr, rule, sheet, topAnimate, _base, _base1, _i, _j, _len, _len1, _ref4, _ref5;
      rowStr = _css_variables.selectors.card + "[data-row=\"" + d.row + "\"]";
      colStr = _css_variables.selectors.card + "[data-col=\"" + d.col + "\"]";
      _css_variables.dimensions = _css_variables.dimensions || {};
      leftAnimate = _css_variables.dimensions[colStr];
      topAnimate = _css_variables.dimensions[rowStr];
      if (!((leftAnimate != null) && (topAnimate != null))) {
        mysheet = null;
        _ref4 = document.styleSheets;
        for (index = _i = 0, _len = _ref4.length; _i < _len; index = ++_i) {
          sheet = _ref4[index];
          if (_css_variables.styleSheet === sheet.href.split("/").pop()) {
            mysheet = sheet;
            break;
          }
        }
        if (mysheet === null) {
          $card.attr('data-row', d.row);
          $card.attr('data-col', d.col);
          $card.css('opacity', '1');
          return;
        }
        myrules = (_ref5 = mysheet.cssRules) != null ? _ref5 : mysheet.rules;
        for (index = _j = 0, _len1 = myrules.length; _j < _len1; index = ++_j) {
          rule = myrules[index];
          if (rule.selectorText === rowStr) {
            topAnimate = rule.style.top;
            _css_variables.dimensions[rowStr] = topAnimate;
          } else if (rule.selectorText === colStr) {
            leftAnimate = rule.style.left;
            _css_variables.dimensions[colStr] = leftAnimate;
          }
        }
      }
      options.animate.properties.top = topAnimate;
      options.animate.properties.left = leftAnimate;
      if ((_base = options.animate.options).duration == null) {
        _base.duration = "slow";
      }
      if ((_base1 = options.animate.options).easing == null) {
        _base1.easing = "swing";
      }
      options.animate.options.always = function() {
        $card.attr('data-row', d.row);
        $card.attr('data-col', d.col);
        return $card.css('opacity', '1');
      };
      /*
      The animation becomes confusing and inaccurate when to many animations are attempted on the same card;Solution: Stop current and pending animations and start just this one.
      */

      return $card.stop(true, false).animate(options.animate.properties, options.animate.options);
    };
    _apply_deck = function() {
      var $card, applied_card_ids, col, cols, d, id, isDragging, row, row_max, row_max_value;
      row_max = 0;
      applied_card_ids = {};
      isDragging = true;
      for (row in __deck) {
        cols = __deck[row];
        for (col in cols) {
          id = cols[col];
          if (applied_card_ids[id] == null) {
            applied_card_ids[id] = true;
            $card = __cards_by_id[id];
            d = __card_data_by_id[id];
            $card.attr('data-card-id', id);
            if (isDragging && !$card.hasClass("draggable")) {
              _apply_transition($card, d);
            } else {
              $card.attr('data-row', d.row);
              $card.attr('data-col', d.col);
            }
            $card.attr('data-row-span', d.row_span);
            $card.attr('data-col-span', d.col_span);
            row_max_value = d.row + d.row_span - 1;
            if (row_max_value > __row_max) {
              __row_max = row_max_value;
            }
          }
        }
      }
      return $deck.attr('data-row-max', row_max);
    };
    /*
    # Initially, cards will be hidden if the 'data-hidden' attribute is true, or
    #   if the deck's 'remove-empty' attribute is true, and
    #   there is no card content, and
    #   there is no 'data-url' attribute
    */

    _should_remove_card_in_init = function($card, $deck) {
      return $card.data('hidden') === true || ($deck.data('remove-empty') === true && !$card.find(_css_variables.selectors.card_content).text().trim() && !$card.data('url'));
    };
    _init_deck_header = function($deck) {
      var $deck_wrapper, $dropdown, title;
      title = $deck.data("title");
      if (!title) {
        $deck.attr("data-title", $deck.attr("id"));
        title = $deck.attr("id");
      }
      $deck_wrapper = $(_init_deck_wrapper($deck));
      $deck.replaceWith($deck_wrapper);
      $deck_wrapper.append($deck);
      $dropdown = $deck_wrapper.find(_css_variables.selectors.removed_dropdown);
      if ($dropdown.find('ul').children().size() === 0) {
        $dropdown.hide();
      }
      return true;
    };
    _init_deck_wrapper = function($deck) {
      return "       <div class=\"" + _css_variables.classes.deck_container + "\">\n       <div class=\"deck-header\">\n       <div class=\"wrapper\">\n       <div class=\"" + _css_variables.classes.deck_title + "\">" + ($deck.data("title") || "") + "</div>\n       <div class=\"deck-controls\">\n" + (_init_card_add_remove()) + "\n" + (_init_card_scroll($deck)) + "\n       </div>\n       </div>\n       </div>";
    };
    _init_card_add_remove = function() {
      return "<div class=\"btn-group " + _css_variables.classes.removed_dropdown + "\">\n<span class=\"dropdown-toggle control add\" data-toggle=\"dropdown\"></span>\n<ul class=\"dropdown-menu pull-right\"></ul>\n</div>";
    };
    _init_card_scroll = function($deck) {
      return "<div id=\"" + ($deck.attr("id")) + "-nav\" class=\"btn-group " + _css_variables.classes.card_jump_scroll + "\">\n<span class=\"dropdown-toggle control jump-card\" data-toggle=\"dropdown\"></span>\n<ul class=\"dropdown-menu pull-right\"></ul>\n</div>";
    };
    _layout_check = function($cards) {
      var result;
      result = true;
      $cards.each(function(index) {
        var $card;
        $card = $(this);
        if (!(($card.attr("data-row") != null) && ($card.attr("data-col") != null))) {
          console.log("card does not have row and col specified");
          result = false;
          return false;
        }
      });
      console.log("all cards have row, col specified", result);
      return result;
    };
    init = function() {
      var callback, cards, remainStatic, _i, _len, _ref4;
      __col_max = $deck.data('col-max');
      _init_deck_header($deck);
      cards = $deck.children(_css_variables.selectors.card);
      remainStatic = _layout_check(cards);
      cards.each(function() {
        var $card, $cheight, $theight, d;
        $card = $(this);
        if (_should_remove_card_in_init($card, $deck)) {
          $card.remove();
        } else {
          d = {
            id: __next_id++,
            row: parseInt($card.attr('data-row')),
            col: parseInt($card.attr('data-col')),
            row_span: parseInt($card.attr('data-row-span')),
            col_span: parseInt($card.attr('data-col-span'))
          };
          __cards_by_id[d.id] = $card;
          __card_data_by_id[d.id] = d;
          _add_card($card, d, remainStatic);
        }
        $cheight = $(this).height();
        $theight = $('.deckster-card-title', this).height() + 40;
        $('.deckster-card-title', this).css('margin-top', -$theight);
        return $(this).css('padding-top', $theight);
      });
      _apply_deck();
      cards.append("<div class='" + _css_variables.classes.controls + "'></div>");
      _ref4 = __event_callbacks[__events.inited] || [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        callback = _ref4[_i];
        if (callback($deck, cards) === false) {
          break;
        }
      }
      _create_jump_scroll_card($deck);
      return _create_jump_scroll_deck(0xDEADBEEF);
    };
    _adjust_adjacent_decks = function($deck) {
      /*
      deckId = $deck.attr("id")
      specs = _window.__deck_mgr.lookup[deckId]
      new_layout = {}
      
      #copy decks up to deck being modified
      for row in [1...specs.row_min]
        new_layout[row] = _window.__deck_mgr.layout[row]
      
      
      #add current deck
      for row,cols of __deck
        new_layout[specs.row_min-1+row] = {}
        new_layout[specs.row_min-1+row][col] = deckId for col in [1..__col_max]
      
      #add back buffer
      newRow = __row_max+specs.row_min
      new_layout[newRow] = {}
      new_layout[newRow][i] = _css_variables.buffer for i in [1..__col_max]
      
      # copy rest
      # (note: our previous buffer, for this deck, will be copied over when iterating
      # over the 'specs.row_max' row)
      newRow += 1
      prevId = -1
      for row in [(specs.row_max+1).._window.__deck_mgr.row]
        new_layout[newRow] = _window.__deck_mgr.layout[row]
      
        # Update global deck placements
        id = new_layout[newRow][1] #
        if id != prevId and id != _css_variables.buffer
          _window.__deck_mgr.lookup[id].row_min = newRow
          _window.__deck_mgr.lookup[id].row_max = newRow
          prevId = id
        else
          _window.__deck_mgr.lookup[prevId].row_max = newRow
      
      
        newRow+=1
      */

      /*
        Update global variables.
        -New overall max row (note: the for loop increments this value 1 extra time when exiting for-loop)
        -New Layout
        -Deck Max
      */

      /*
      _window.__deck_mgr.row = newRow-1
      console.log("_window.__deck_mgr.row",_window.__deck_mgr.row)
      _window.__deck_mgr.layout = new_layout # new layout
      console.log("layout",_window.__deck_mgr.layout)
      console.log("__row_max!",__row_max)
      _window.__deck_mgr.lookup[deckId].row_max = specs.row_min+__row_max
      */

      $deck.closest(_css_variables.selectors.deck_container).attr("data-row-max", __row_max + 1);
      return true;
    };
    /*
      Adjust (if necessary) other decks when a particular deck is expanded/collapsed or its contents are moved around.
    */

    _on(__events.card_collapsed, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.card_expanded, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.card_moved, function($deck, $card) {
      return _adjust_adjacent_decks($deck);
    });
    _on(__events.inited, function($deck) {
      /*
      col_min = 1 # Should only be 1 as we will only be scrolling vertically
      deckId = $deck.attr("id")
      #How many decks "rows" are there currently?
      if _window.__deck_mgr.row?
        #Start at the next available row
        row_min = _window.__deck_mgr.row+1
      else
        row_min = 1
      
      #Max width for this deck
      col_max = __col_max
      #There's an extra row between decks to act as a buffer
      row_max = row_min+__row_max
      
      _window.__deck_mgr.layout = _window.__deck_mgr.layout || {}
      for y in [row_min..row_max]
        for x in [col_min..col_max]
      
          unless _window.__deck_mgr.layout[y]
            _window.__deck_mgr.layout[y] = {}
      
          _window.__deck_mgr.layout[y][x] = if y == row_max then _css_variables.buffer else $deck.attr("id")
      
      #Maximum number of rows
      _window.__deck_mgr.row = row_max
      _window.__deck_mgr.lookup = _window.__deck_mgr.lookup || {}
      #Record results
      _window.__deck_mgr.lookup[deckId] =
        "row_min":row_min
        "row_max":row_max
        "col_max":col_max
        "col_min":col_min
      */

      $deck.closest(_css_variables.selectors.deck_container).attr("data-row-max", __row_max + 1);
      return true;
    });
    _on(__events.card_added, function($card, d) {
      var $title_div, title;
      title = $card.data("title");
      if (!((title != null) && !$card.find(_css_variables.selectors.card_title).text())) {
        return;
      }
      $title_div = $('<div>').text(title).addClass(_css_variables.classes.card_title);
      return $card.prepend($title_div);
    });
    _does_fit_location = function(row, col, d) {
      var col_end, col_test, row_end, row_test, _i, _j;
      row_end = d.row_span + row;
      col_end = d.col_span + col;
      if (col_end - 1 > __col_max) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (__deck[row_test] && __deck[row_test][col_test]) {
            return false;
          }
        }
      }
      return true;
    };
    _ajax = function(options) {
      options = $.extend(true, {}, _ajax_default, options);
      return $.ajax(options);
    };
    if (options['url_enabled'] === true) {
      _on(__events.card_added, function($card, d) {
        var ajax_options, cardId, deckId;
        if ($card.data("url") != null) {
          ajax_options = {
            url: $card.data("url"),
            type: $card.data("url-method") != null ? $card.data("url-method") : "GET",
            context: $card,
            success: function(data, status, response) {
              var divText;
              if (!!data.trim()) {
                return this.find(_css_variables.selectors.card_content).html(data);
              } else {
                divText = this.find(_css_variables.selectors.card_content).text();
                if (!divText.trim() && $deck.data('remove-empty') === true) {
                  _create_jump_scroll_card($deck);
                  this.remove();
                  return _remove_card_from_deck(this);
                }
              }
            }
          };
          deckId = $card.closest(_css_variables.selectors.deck).attr("id");
          cardId = $card.attr("id");
          /*
           Keep track of requests incase we need to abort them.
          */

          _ajax_requests[deckId] = _ajax_requests[deckId] || {};
          return _ajax_requests[deckId][cardId] = _ajax(ajax_options);
        }
      });
    }
    if (options['draggable'] && options['draggable'] === true) {
      __$active_drag_card = void 0;
      __active_drag_card_drag_data = void 0;
      _on(__events.inited, function($deck) {
        var controls;
        controls = "<a title='Drag' class='" + _css_variables.classes.drag_handle + " control drag'></a>";
        return $deck.find(_css_variables.selectors.controls).append(controls);
      });
      _on(__events.inited, function($deck) {
        return _bind_drag_controls(this);
      });
      _create_box = function($card, clazz) {
        var $div;
        $div = $("<div/>").addClass(clazz).addClass("deckster-card").attr("data-col", $card.attr("data-col")).attr("data-row", $card.attr("data-row")).attr("data-col-span", $card.attr("data-col-span")).attr("data-row-span", $card.attr("data-row-span"));
        return $div;
      };
      _bind_drag_controls = function(deck) {
        $deck.find(_css_variables.selectors.drag_handle).on("mousedown", function(e) {
          var $drag_handle;
          $drag_handle = $(this);
          __$active_drag_card = $drag_handle.parents(_css_variables.selectors.card);
          __$active_drag_card.addClass('draggable');
          __$active_drag_card.css('z-index', 1000);
          $deck.append(_create_box(__$active_drag_card, "shadowbox"));
          __$active_drag_card.css('z-index', '1000');
          __active_drag_card_drag_data = {
            height: __$active_drag_card.outerHeight(),
            width: __$active_drag_card.outerWidth(),
            pos_y: __$active_drag_card.offset().top + __$active_drag_card.outerHeight() - e.pageY,
            pos_x: __$active_drag_card.offset().left + __$active_drag_card.outerWidth() - e.pageX
          };
          __active_drag_card_drag_data['original_top'] = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
          __active_drag_card_drag_data['original_left'] = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
          return e.preventDefault();
        });
        $deck.on('mousemove', function(e) {
          var $shadowbox, left, messages, new_left, new_top, original_left, original_top, top;
          if (__$active_drag_card != null) {
            new_top = e.pageY + __active_drag_card_drag_data['pos_y'] - __active_drag_card_drag_data['height'];
            new_left = e.pageX + __active_drag_card_drag_data['pos_x'] - __active_drag_card_drag_data['width'];
            original_left = __active_drag_card_drag_data['original_left'];
            original_top = __active_drag_card_drag_data['original_top'];
            $shadowbox = $(".shadowbox");
            top = parseInt($shadowbox.attr("data-row"));
            left = parseInt($shadowbox.attr("data-col"));
            messages = [];
            if (new_top - original_top < -200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] - 200;
              _move_card(__$active_drag_card, "up");
              top -= 1;
              messages.push('UP');
            }
            if (new_top - original_top > 200) {
              __active_drag_card_drag_data['original_top'] = __active_drag_card_drag_data['original_top'] + 200;
              _move_card(__$active_drag_card, "down");
              top += 1;
              messages.push('DOWN');
            }
            if (new_left - original_left < -300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] - 300;
              _move_card(__$active_drag_card, "left");
              left -= 1;
              messages.push('LEFT');
            }
            if (new_left - original_left > 300) {
              __active_drag_card_drag_data['original_left'] = __active_drag_card_drag_data['original_left'] + 300;
              _move_card(__$active_drag_card, "right");
              left += 1;
              messages.push('RIGHT');
            }
            if (messages.length > 0) {
              console.log(messages.join(' '));
            }
            $shadowbox.attr("data-col", left);
            $shadowbox.attr("data-row", top);
            return __$active_drag_card.offset({
              top: new_top,
              left: new_left
            });
          }
        });
        return $deck.on('mouseup', function(e) {
          if (__$active_drag_card != null) {
            __$active_drag_card.removeClass('draggable');
            __$active_drag_card.css('top', '');
            __$active_drag_card.css('left', '');
            __$active_drag_card.css('z-index', '');
            __$active_drag_card.css('opacity', '1');
            $(".shadowbox").fadeOut("slow", function() {
              return $(this).remove();
            });
            __$active_drag_card = void 0;
            return __active_drag_card_drag_data = void 0;
          }
        });
      };
      _move_card = function($card, direction) {
        var d, id;
        id = $card.data('card-id');
        d = __card_data_by_id[id];
        switch (direction) {
          case 'left':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col - 1
            });
            break;
          case 'right':
            _force_card_to_position($card, d, {
              row: d.row,
              col: d.col + 1
            });
            break;
          case 'up':
            _force_card_to_position($card, d, {
              row: d.row - 1,
              col: d.col
            });
            break;
          case 'down':
            _force_card_to_position($card, d, {
              row: d.row + 1,
              col: d.col
            });
        }
        return _apply_deck();
      };
    }
    if (options['drag_expand'] && options['drag_expand'] === true) {
      __$active_dragging_card = void 0;
      __$active_dragging_placeholder = void 0;
      __active_dragging_data = void 0;
      __col_threshold_min = 300;
      __col_threshold_max = 300;
      __row_threshold_min = 200;
      __row_threshold_max = 200;
      width_min_limit = false;
      width_max_limit = false;
      height_min_limit = false;
      height_max_limit = false;
      _init_drag_expand = function() {
        return " \n<div style=\"float:right\">\n  <span class=\"" + _css_variables.classes.drag_mod_handle + "\">D</span>\n</div>";
      };
      _limit_reached = function(width, height) {
        var $placeholder;
        $placeholder = _placeholder_div(__$active_dragging_card, __active_dragging_data.d);
        $placeholder.width(width);
        $placeholder.height(height);
        $placeholder.css("position", "aboslute");
        $placeholder.css("z-index", "2000");
        $placeholder.css("background-color", "red");
        $deck.append($placeholder);
        return $placeholder.fadeOut("slow", function() {
          return $(_css_variables.selectors.placeholders).remove();
        });
      };
      _expand_card = function() {
        var col, col_mod, row, row_mod;
        col_mod = Math.round((__active_dragging_data.width - __active_dragging_data.delta_width) / __col_threshold_min);
        row_mod = Math.round((__active_dragging_data.height - __active_dragging_data.delta_height) / __row_threshold_min);
        console.log("col_mod", col_mod);
        console.log("row_mod", row_mod);
        row = parseInt(__$active_dragging_card.attr("data-row-span"));
        col = parseInt(__$active_dragging_card.attr("data-col-span"));
        console.log("row", row);
        console.log("col", col);
        row += row_mod;
        col += col_mod;
        __$active_dragging_card.height("");
        __$active_dragging_card.width("");
        __$active_dragging_card.attr("data-row-span", row);
        __$active_dragging_card.attr("data-col-span", col);
        __active_dragging_data.d["col_span"] = col;
        __active_dragging_data.d["row_span"] = row;
        if (col_mod !== 0 || row_mod !== 0) {
          console.log("adjusting deck");
          __$active_dragging_placeholder.attr("data-row-span", row);
          __$active_dragging_placeholder.attr("data-col-span", col);
          _force_card_to_position(__$active_dragging_card, __active_dragging_data.d, {
            row: __active_dragging_data.d.row,
            col: __active_dragging_data.d.col
          });
          return _apply_deck();
        }
      };
      _width_check = function(currentX, diff) {
        /* Min Width Check*/

        var widthCheck;
        widthCheck = __$active_dragging_card.outerWidth() + diff;
        console.log("currentX", currentX);
        console.log("widthCheck", widthCheck);
        if (__col_threshold_min <= widthCheck && widthCheck <= __col_threshold_max) {
          __active_dragging_data.width += diff;
          /* Give User One-Time Warning  
          unless width_min_limit
            _limit_reached(__active_dragging_data.width,__active_dragging_data.height)
            width_min_limit = true
          */

        }
        /* Max Width Check*/

        return __active_dragging_data.x = currentX;
      };
      _height_check = function(currentY, diff) {
        /* Min Height Check*/

        var heightCheck;
        heightCheck = __$active_dragging_card.outerHeight() + diff;
        if (__row_threshold_min <= heightCheck && heightCheck <= __row_threshold_max) {
          __active_dragging_data.height += diff;
        }
        return __active_dragging_data.y = currentY;
        /* Max Width Check 
        if __active_dragging_data.height > __$active_dragging_card.outerHeight() 
          __active_dragging_data.height = __row_threshold_max
        Give User One-Time Warning  
          unless height_max_limit
            _limit_reached(__active_dragging_data.width,__active_dragging_data.height)
            height_max_limit = true
        */

      };
      _init_drag_expand_callbacks = function() {
        /* Init Dragging Process*/

        var $drag_handles;
        $drag_handles = $deck.find(_css_variables.selectors.drag_mod_handle);
        $drag_handles.on("mousedown", function(event) {
          var $card, $container, cardId, _d;
          console.log("drag mousedown");
          $card = $(this).closest(_css_variables.selectors.card);
          cardId = parseInt($card.data("card-id"));
          _d = __card_data_by_id[cardId];
          __$active_dragging_card = $card;
          /* Increase z-index for visual purposes*/

          __$active_dragging_card.attr("data-prev-z", __$active_dragging_card.css("z-index"));
          __$active_dragging_card.css("z-index", "1000");
          /* Reset Limit Check*/

          width_min_limit = false;
          width_max_limit = false;
          height_min_limit = false;
          height_max_limit = false;
          $container = $card.closest(_css_variables.selectors.deck_container);
          __col_threshold_max = $container.width();
          __row_threshold_max = $container.height();
          console.log("row max", __row_threshold_max);
          console.log("col max", __col_threshold_max);
          /* Set metadata for our expanding purposes*/

          __active_dragging_data = {
            d: _d,
            x: event.pageX,
            y: event.pageY,
            delta_width: $card.width(),
            delta_height: $card.height(),
            width: $card.width(),
            height: $card.height(),
            orig_width: $card.width(),
            orig_height: $card.height()
          };
          /* Add Shadowbox*/

          __$active_dragging_placeholder = _placeholder_div($card, _d);
          return __$active_dragging_placeholder.css("background-color", "blue");
        });
        $deck.on("mousemove", function(event) {
          var col_change, currentX, currentY, row_change;
          if (__$active_dragging_card != null) {
            currentX = event.pageX;
            currentY = event.pageY;
            _width_check(currentX, currentX - __active_dragging_data.x);
            _height_check(currentY, currentY - __active_dragging_data.y);
            /* Set Height && Width*/

            __$active_dragging_card.width(__active_dragging_data.width);
            __$active_dragging_card.height(__active_dragging_data.height);
            /* Move surrounding cards if expanding / collapsing has reached a certain points*/

            col_change = __active_dragging_data.width - __active_dragging_data.delta_width;
            if (col_change > __col_threshold_min || col_change < -__col_threshold_min) {
              console.log("col_change", col_change);
              _expand_card();
              __active_dragging_data.delta_width += col_change;
            }
            row_change = __active_dragging_data.height - __active_dragging_data.delta_height;
            if (row_change > __row_threshold_min || row_change < -__row_threshold_min) {
              console.log("row_change", row_change);
              _expand_card();
              return __active_dragging_data.delta_height += row_change;
            }
          }
        });
        return $deck.on("mouseup", function(event) {
          var col_change, currentX, currentY, row_change;
          console.log("drag mouseup");
          if (__$active_dragging_card != null) {
            /* set card's final height and width*/

            currentX = event.pageX;
            currentY = event.pageY;
            _width_check(currentX, currentX - __active_dragging_data.x);
            _height_check(currentY, currentY - __active_dragging_data.y);
            __$active_dragging_card.width(__active_dragging_data.width);
            __$active_dragging_card.height(__active_dragging_data.height);
            /* Move surrounding cards if expanding / collapsing has reached a certain points*/

            col_change = __active_dragging_data.width - __active_dragging_data.delta_width;
            if (col_change > __col_threshold_min || col_change < -__col_threshold_min) {
              console.log("col_change", col_change);
              _expand_card();
              __active_dragging_data.delta_width += col_change;
            }
            row_change = __active_dragging_data.height - __active_dragging_data.delta_height;
            if (row_change > __row_threshold_min || row_change < -__row_threshold_min) {
              console.log("row_change", row_change);
              _expand_card();
              __active_dragging_data.delta_height += row_change;
            }
            /* Set z-index back to what it was before*/

            __$active_dragging_card.css("z-index", __$active_dragging_card.attr("data-prev-z"));
            __$active_dragging_card.removeAttr("data-prev-z");
            /* Remove Shadowbox*/

            __$active_dragging_placeholder.remove();
            __$active_dragging_placeholder = void 0;
            /* Adjust Deck Height if necessary*/

            _clean_up_deck();
            _adjust_adjacent_decks($deck);
            /* Reset ivars*/

            __$active_dragging_card = void 0;
            return __active_dragging_data = void 0;
          }
        });
      };
      _on(__events.inited, function($deck) {
        console.log("Adding D-Expand");
        /* Add Draging Icon*/

        $deck.find(_css_variables.selectors.card).each(function(index) {
          return $(this).append(_init_drag_expand());
        });
        /* Add Callback*/

        return _init_drag_expand_callbacks();
      });
    }
    _placeholder_div = function($card, _d) {
      var $placeholder;
      $placeholder = $("<div>").addClass(_css_variables.classes.placeholders).addClass(_css_variables.classes.card).attr("data-col", _d["col"]).attr("data-row", _d["row"]).attr("data-col-span", _d.col_span).attr("data-row-span", _d.row_span);
      $card.closest(_css_variables.selectors.deck).append($placeholder);
      return $placeholder;
    };
    _remove_old_position = function($card, d) {
      var col_end, col_remove, row_end, row_remove, _i, _j, _ref4, _ref5;
      row_end = d.row + d.row_span - 1;
      col_end = d.col + d.col_span - 1;
      for (row_remove = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_remove = _ref4 <= row_end ? ++_i : --_i) {
        for (col_remove = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_remove = _ref5 <= col_end ? ++_j : --_j) {
          if (!__deck[row_remove]) {
            break;
          }
          if (__deck[row_remove][col_remove] === d.id) {
            delete __deck[row_remove][col_remove];
          }
        }
      }
      return true;
    };
    _set_new_position = function($card, d, settings) {
      var col_add, col_end, deck, row_add, row_end, _i, _j, _ref4, _ref5;
      deck = settings && settings.deck ? settings.deck : __deck;
      row_end = d.row_span + d.row - 1;
      col_end = d.col_span + d.col - 1;
      for (row_add = _i = _ref4 = d.row; _ref4 <= row_end ? _i <= row_end : _i >= row_end; row_add = _ref4 <= row_end ? ++_i : --_i) {
        if (!deck[row_add]) {
          deck[row_add] = {};
        }
        for (col_add = _j = _ref5 = d.col; _ref5 <= col_end ? _j <= col_end : _j >= col_end; col_add = _ref5 <= col_end ? ++_j : --_j) {
          deck[row_add][col_add] = d.id;
        }
      }
      if (row_end > __row_max) {
        __row_max = row_end;
      }
      _clean_up_deck(settings);
      return true;
    };
    _clean_up_deck = function(settings) {
      var deck, row_subtractor, _results;
      deck = settings && settings.deck ? settings.deck : __deck;
      row_subtractor = __row_max;
      _results = [];
      while (row_subtractor > 0) {
        if ($.isEmptyObject(deck[row_subtractor])) {
          delete deck[row_subtractor];
          if (__row_max === row_subtractor) {
            __row_max -= 1;
          }
        }
        _results.push(row_subtractor -= 1);
      }
      return _results;
      /*
      if settings and settings.readjust
        r = 1
        while r <= __row_max
          empty_rows = 0
          while r <= __row_max and deck[r] == undefined
            empty_rows += 1
            r += 1
      
          if empty_rows > 0
            processed = {}
            for row_move in [r..__row_max]
              for c, id of __deck[row_move]
                  if processed[id] == undefined
                    processed[id] = true
                    d = __card_data_by_id[id]
                    d.row -= empty_rows
                    __cards_by_id[id].attr("data-row",d.row)
      
          r += 1
      */

    };
    _fit_location = function(row, col, d, settings) {
      var col_end, col_test, deck, row_end, row_test, _i, _j;
      deck = settings && settings.deck ? settings.deck : __deck;
      row_end = d.row_span + row - 1;
      col_end = d.col_span + col - 1;
      if (col_end > __col_max || row_end < 1 || row < 1) {
        return false;
      }
      for (row_test = _i = row; row <= row_end ? _i <= row_end : _i >= row_end; row_test = row <= row_end ? ++_i : --_i) {
        for (col_test = _j = col; col <= col_end ? _j <= col_end : _j >= col_end; col_test = col <= col_end ? ++_j : --_j) {
          if (deck[row_test] && deck[row_test][col_test]) {
            if (settings && settings.ignoreId && settings.ignoreId === deck[row_test][col_test]) {
              continue;
            } else {
              return false;
            }
          }
        }
      }
      return true;
    };
    _placeholder_callbacks = function($placeholder, _d) {
      $placeholder.click(function(action) {
        var $card, $selectedCard;
        $card = __cards_by_id[_d.id];
        _remove_old_position($card, __card_data_by_id[_d.id]);
        $selectedCard = $(action.currentTarget);
        __card_data_by_id[_d.id] = _d;
        _set_new_position($card, _d);
        _apply_transition($card, _d);
        return $card.find(_css_variables.selectors.droppable).trigger("click");
      });
      $placeholder.mouseenter(function(action) {
        return $(this).css("z-index", 3000);
      });
      return $placeholder.mouseleave(function(action) {
        return $(this).css("z-index", "");
      });
    };
    _add_placeholders = function($card, d) {
      var $placeholder, col, new_d, row, _i, _j, _ref4;
      for (row = _i = 1, _ref4 = __row_max + 1; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; row = 1 <= _ref4 ? ++_i : --_i) {
        for (col = _j = 1; 1 <= __col_max ? _j <= __col_max : _j >= __col_max; col = 1 <= __col_max ? ++_j : --_j) {
          if (_fit_location(row, col, d)) {
            new_d = {
              "id": d.id,
              "row": row,
              "col": col,
              "row_span": d.row_span,
              "col_span": d.col_span
            };
            $placeholder = _placeholder_div($card, new_d);
            _placeholder_callbacks($placeholder, new_d);
          }
        }
      }
      return -1;
    };
    /*
      If set to true, cards can be picked up and dropped to a new spot on the deck without disturbing the positions of any other card.
      :Droppable Helper Methods End.
    */

    if (options.droppable === true) {
      _on(__events.inited, function($card, d) {
        var $controls, $droppable;
        $controls = $card.find(_css_variables.selectors.controls);
        $droppable = $("<a title='Drop' class='" + _css_variables.classes.droppable + " control droppable1'></a>");
        $droppable.click(function(element) {
          var $drop_handle, callback, id, retain_callbacks, _i, _len, _ref4;
          $drop_handle = $(element.currentTarget);
          if (!$drop_handle.hasClass("cancel")) {
            $card = $drop_handle.closest(_css_variables.selectors.card);
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(":visible").addClass("hider").hide();
            $deck.closest(_css_variables.selectors.deck_container).nextAll(_css_variables.selectors.deck_container).hide();
            $drop_handle.show();
            $drop_handle.addClass("cancel");
            id = parseInt($card.attr('data-card-id'));
            d = __card_data_by_id[id];
            return _add_placeholders($card, d);
          } else {
            $drop_handle.removeClass("cancel");
            $card = $drop_handle.closest(_css_variables.selectors.card);
            $deck = $drop_handle.closest(_css_variables.selectors.deck);
            $deck.find(_css_variables.selectors.controls).children(".hider").show().removeClass("hider");
            $deck.find(_css_variables.selectors.placeholders).remove();
            $(document).find(_css_variables.selectors.deck_container).show();
            retain_callbacks = [];
            _ref4 = __event_callbacks[__events.card_moved] || [];
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              callback = _ref4[_i];
              if (callback($deck, $card) !== false) {
                retain_callbacks.push(callback);
              }
            }
            return __event_callbacks[__events.card_moved] = retain_callbacks;
          }
        });
        return $controls.append($droppable);
      });
    }
    if (options['expandable'] && options['expandable'] === true) {
      _on(__events.inited, function($deck, cards) {
        var controls;
        controls = "<a title=\"Expand\" class='" + _css_variables.classes.expand_handle + " control expand'></a>\n<a title=\"Collapse\" class='" + _css_variables.classes.collapse_handle + " control collapse' style='display:none;'></a>";
        cards.each(function() {
          var $card, col_expand, row_expand;
          $card = $(this);
          row_expand = $card.attr('data-row-expand');
          col_expand = $card.attr('data-col-expand');
          if ((row_expand != null) || (col_expand != null)) {
            return $card.find(_css_variables.selectors.controls).append(controls);
          }
        });
        $deck.find(_css_variables.selectors.expand_handle).click(function() {
          return _click_to_expand(this);
        });
        return $deck.find(_css_variables.selectors.collapse_handle).click(function() {
          return _click_to_collapse(this);
        });
      });
      _expand_on_click = function(element) {
        var $card, $expand_handle, callback, d, expandColTo, expandRowTo, id, _i, _len, _ref4, _results;
        $expand_handle = $(element);
        $card = $expand_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        console.log([
          'Expand <<<', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        $card.attr('data-original-col', d.col);
        $card.attr('data-original-row-span', d.row_span);
        $card.attr('data-original-col-span', d.col_span);
        if ($card.data("col-expand") != null) {
          expandColTo = parseInt($card.data("col-expand"));
          expandColTo = expandColTo > __col_max ? __col_max : expandColTo;
        }
        expandColTo = (expandColTo != null) && expandColTo > 0 ? expandColTo : d.col_span;
        if ($card.data("row-expand") != null) {
          expandRowTo = parseInt($card.data("row-expand"));
        }
        expandRowTo = (expandRowTo != null) && expandRowTo > 0 ? expandRowTo : d.row_span;
        d['row_span'] = expandRowTo;
        d['col'] = (expandColTo - 1) + d.col <= __col_max ? d.col : 1;
        d['col_span'] = expandColTo;
        if (d.col_span === $card.data('original-col-span') && d.row_span === $card.data('original-row-span')) {
          return;
        }
        console.log([
          'Expand >>>', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $expand_handle.hide();
        $expand_handle.siblings(_css_variables.selectors.collapse_handle).show();
        _ref4 = __event_callbacks[__events.card_expanded] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _collapse_on_click = function(element) {
        var $card, $collapse_handle, callback, d, id, _i, _len, _ref4, _results;
        $collapse_handle = $(element);
        $card = $collapse_handle.parents(_css_variables.selectors.card);
        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        d.col = parseInt($card.attr('data-original-col'));
        d.row_span = parseInt($card.attr('data-original-row-span'));
        d.col_span = parseInt($card.attr('data-original-col-span'));
        $card.attr('data-original-col', '');
        $card.attr('data-original-row-span', '');
        $card.attr('data-original-col-span', '');
        _force_card_to_position($card, d, {
          row: d.row,
          col: d.col
        });
        _apply_deck();
        $collapse_handle.hide();
        $collapse_handle.siblings(_css_variables.selectors.expand_handle).show();
        _clean_up_deck();
        _ref4 = __event_callbacks[__events.card_collapsed] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _on(__events.inited, function() {
        return $(_css_variables.selectors.deck + ":not(" + _css_variables.selector_functions.deck_expanded(false) + ")").each(function(index) {
          $deck = $(this);
          return $deck.find(_css_variables.selectors.card + ":not(" + _css_variables.selector_functions.card_expanded(false) + ")").each(function(index) {
            return $(this).find(_css_variables.selectors.expand_handle).trigger("click");
          });
        });
      });
      _card_changed = function($deck, $card, type) {
        var $cardContent, action, ajaxOptions, cardActions, cardId, cardIdentity, deckId, temp;
        if ((options["card-actions"] != null) && (options["card-actions"][type] != null)) {
          cardActions = options["card-actions"][type];
          deckId = $deck.attr("id");
          cardId = $card.attr("id");
          $cardContent = $card.find(_css_variables.selectors.card_content);
          for (cardIdentity in cardActions) {
            action = cardActions[cardIdentity];
            if ("#" + $card.attr("id") === cardIdentity || $card.hasClass(cardIdentity.slice(1)) || cardIdentity === "*") {
              temp = action($card, $cardContent);
              if ((temp != null) && (temp.url != null)) {
                /*
                   Abort any requests that are currently on-going.
                */

                if (_ajax_requests[deckId] && _ajax_requests[deckId][cardId]) {
                  _ajax_requests[deckId][cardId].abort();
                  delete _ajax_requests[deckId][cardId];
                }
                /*
                  Send the ajax request after any card animation has finished (Typically when a card is expanded its size will be changed.) For example, trying to animate and load content into the card makes both operations laggy and detract from the user experience.
                */

                ajaxOptions = temp;
                $card.queue().push(function() {
                  return _ajax_requests[deckId][cardId] = _ajax(ajaxOptions);
                });
              }
            }
          }
        }
        /* Call any globally registered callbacks*/

        if ((_document.__deck_mgr != null) && (_document.__deck_mgr["card-actions"] != null) && (_document.__deck_mgr["card-actions"][type] != null)) {
          return _document.__deck_mgr["card-actions"][type]($card, $cardContent);
        }
      };
      /* COLLAPSING*/

      _collapse_card = function($card) {
        var col, col_end, d, id, moving_info, o_col, o_col_end, o_col_span, o_row_span, row, row_span;
        moving_info = {};
        /* Get Card*/

        id = parseInt($card.attr("data-card-id"));
        d = __card_data_by_id[id];
        /* Remove old position/size of card*/

        _remove_old_position($card, d);
        /* Calculate New Dimensions*/

        /* Orig. dims*/

        o_col_span = d['original-col-span'];
        o_col = d['original-col-offset'];
        o_col_end = o_col + o_col_span - 1;
        o_row_span = d['original-row-span'];
        /* Curent dims*/

        col = d.col;
        col_end = d.col + d.col_span - 1;
        row_span = d.row_span;
        row = d.row;
        /* Set back origional values*/

        d.col += o_col;
        d.col_span = o_col_span;
        d.row_span = o_row_span;
        delete d['original-row-span'];
        delete d['original-col-span'];
        delete d['original-col-offset'];
        /* Set the new position/size of card*/

        _set_new_position($card, d);
        /* Moving Metadata*/

        moving_info["col"] = 1;
        moving_info["col_end"] = __col_max;
        moving_info["row"] = row;
        moving_info["id"] = d.id;
        return moving_info;
      };
      /* - Check how far up we can move a card 
          starting at "col" and ending at "col_end".
          - Start looking at row "row"
      */

      _can_move_up = function(col, col_end, row) {
        var c, spaces, _i;
        spaces = 0;
        /* Check for valid params*/

        if (col < 1 || col > __col_max || col_end < col || col_end > __col_max || col_end < 1 || row < 1 || row > __row_max) {
          return 0;
        }
        while (row > 0) {
          for (c = _i = col; col <= col_end ? _i <= col_end : _i >= col_end; c = col <= col_end ? ++_i : --_i) {
            if (__deck[row] !== void 0 && __deck[row][c] !== void 0) {
              return spaces;
            }
          }
          spaces += 1;
          row -= 1;
        }
        return spaces;
      };
      _move_up_cardwise = function() {
        var $card, d, id, new_deck;
        console.log("_adjust_conflicts");
        new_deck = {};
        /* For all cards in the deck*/

        for (id in __card_data_by_id) {
          d = __card_data_by_id[id];
          /* That are currently visible*/

          if (d.isRemoved || info.id === id) {
            continue;
          }
          $card = __cards_by_id[id];
          /* If the card conflicts with our expansion*/

          if (__cards_needing_resolved_by_id[id]) {
            /* Move it down a certain amount of spots (calculated previously)*/

            d.row = d.row + __cards_needing_resolved_by_id[id];
          }
          /* Now set the position of the card on our new deck*/

          _set_new_position($card, d, {
            "deck": new_deck
          });
        }
        /* Set the global var to our new deck*/

        return __deck = new_deck;
      };
      /* Check to the deck to see if we can slide some card's upward*/

      _move_up = function(info) {
        var $card, col, count, d, f_v_spaces, id, row, _i, _j, _ref4, _ref5, _ref6;
        count = 0;
        for (row = _i = _ref4 = info.row; _ref4 <= __row_max ? _i <= __row_max : _i >= __row_max; row = _ref4 <= __row_max ? ++_i : --_i) {
          for (col = _j = _ref5 = info.col, _ref6 = info.col_end; _ref5 <= _ref6 ? _j <= _ref6 : _j >= _ref6; col = _ref5 <= _ref6 ? ++_j : --_j) {
            if (__deck[row] !== void 0 && __deck[row][col] !== void 0) {
              id = __deck[row][col];
              if (__cards_needing_resolved_by_id[id] === void 0) {
                d = __card_data_by_id[id];
                /* Check if we can slide this card directly updward*/

                f_v_spaces = _can_move_up(d.col, d.col + d.col_span - 1, d.row - 1);
                if (f_v_spaces > 0) {
                  /* Move Card Up If Possible To Fill in Empty Spots*/

                  $card = __cards_by_id[id];
                  _remove_old_position($card, d);
                  d.row -= f_v_spaces;
                  _set_new_position($card, d);
                  count += 1;
                }
              }
              __cards_needing_resolved_by_id[id] = true;
            }
          }
        }
        return count;
      };
      _click_to_collapse = function(element) {
        /* Grab Card*/

        var $card, $collapse_handle, callback, info, _i, _len, _ref4;
        $collapse_handle = $(element);
        $card = $collapse_handle.parents(_css_variables.selectors.card);
        /* Collapse Card and retrieve metadata about new deck layout*/

        info = _collapse_card($card);
        /* Move cards up into freed spaces*/

        _move_up(info);
        /* Hide Collapse View*/

        $collapse_handle.hide();
        $collapse_handle.siblings(_css_variables.selectors.expand_handle).show();
        /* Call Collapsing Callbacks*/

        _ref4 = __event_callbacks[__events.card_collapsed] || [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          }
        }
        /* Saves changes made to each card*/

        _apply_deck();
        /* Clear out global helper variables*/

        return __cards_needing_resolved_by_id = {};
      };
      /* EXPANDING*/

      _find_expansion_size = function($card) {
        /* Get Card*/

        var col_end, col_expand, col_span, col_start, d, id, result, row_end, row_expand, row_start;
        id = $card.data("card-id");
        d = __card_data_by_id[id];
        /* Calculate new dimensions*/

        row_expand = parseInt($card.attr("data-row-expand"));
        row_end = d.row + -1 + row_expand;
        row_start = d.row;
        col_start = d.col;
        col_expand = parseInt($card.attr("data-col-expand"));
        col_end = col_start + col_expand - 1;
        /* 
           If necessary, adjust the card to the leftmost space 
           on the deck to accomidate the new size
        */

        while (col_start + col_expand - 1 > __col_max && col_start > 0) {
          col_start -= 1;
          col_end = col_expand + col_start - 1;
        }
        /* If card too wide, truncate*/

        if (col_start === 0) {
          col_start = 1;
          col_end = __col_max;
          col_span = col_end - col_start + 1;
        }
        /* Expanded Card info and metadata*/

        result = {
          "id": id,
          "row": row_start,
          "row_end": row_end,
          "row_span": row_expand,
          "col": col_start,
          "col_end": col_end,
          "col_span": col_expand
        };
        return result;
      };
      _find_conflicting_cards = function(settings) {
        var col_end, d, f_v_spaces, i, id, j, row, row_end, _i, _ref4, _ref5, _results;
        _results = [];
        for (i = _i = _ref4 = settings.row, _ref5 = settings.row_end; _ref4 <= _ref5 ? _i <= _ref5 : _i >= _ref5; i = _ref4 <= _ref5 ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref6, _ref7, _results1;
            _results1 = [];
            for (j = _j = _ref6 = settings.col, _ref7 = settings.col_end; _ref6 <= _ref7 ? _j <= _ref7 : _j >= _ref7; j = _ref6 <= _ref7 ? ++_j : --_j) {
              if (__deck[i] !== void 0 && __deck[i][j] !== void 0 && settings.id !== __deck[i][j]) {
                id = __deck[i][j];
                if (__cards_needing_resolved_by_id[id] === void 0 || __cards_needing_resolved_by_id[id] < settings.blocks_to_move) {
                  d = __card_data_by_id[id];
                  col_end = d.col + d.col_span - 1;
                  row = d.row + settings.blocks_to_move;
                  row_end = row + d.row_span - 1;
                  f_v_spaces = _can_move_up(d.col, col_end, d.row - 1);
                  __cards_needing_resolved_by_id[id] = settings.blocks_to_move - f_v_spaces;
                  _results1.push(_find_conflicting_cards({
                    "id": id,
                    "blocks_to_move": settings.blocks_to_move - f_v_spaces,
                    "col": d.col,
                    "col_end": col_end,
                    "row": d.row,
                    "row_end": row_end
                  }));
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      };
      _identify_intersecting_cards = function(changes) {
        var blocks_to_move, col, col_end, col_start, d, i, id, info, moving_info, processed_cards, row_end, row_start, section_clear, _i, _j, _k, _ref4, _ref5, _ref6;
        moving_info = {};
        moving_info["col_moves"] = {};
        processed_cards = {};
        /* Scan through all rows that intersect with 
            our card's expansion
        */

        for (i = _i = _ref4 = changes.row, _ref5 = changes.row_end; _ref4 <= _ref5 ? _i <= _ref5 : _i >= _ref5; i = _ref4 <= _ref5 ? ++_i : --_i) {
          _ref6 = __deck[i];
          for (col in _ref6) {
            id = _ref6[col];
            if (!(id === void 0 || id === changes.id || processed_cards[id] !== void 0)) {
              processed_cards[id] = true;
              /* Calculate this card's new dimensions*/

              d = __card_data_by_id[id];
              col_start = d.col;
              col_end = d.col + d.col_span - 1;
              blocks_to_move = changes.row - d.row + changes.row_span;
              row_start = d.row + blocks_to_move;
              row_end = row_start + -1 + d.row_span;
              /* If this card's width doesn't fall within our
                  area of concern, skip it
              */

              if (changes.col > col_end || changes.col_end < col_start) {
                console.log("Skipping Card: ", id);
                continue;
              }
              /* We're going to need to push some cards down to make space for our expanded card.
              */

              section_clear = true;
              for (i = _j = col_start; col_start <= col_end ? _j <= col_end : _j >= col_end; i = col_start <= col_end ? ++_j : --_j) {
                if (moving_info["col_moves"] !== void 0 && moving_info["col_moves"][i] > blocks_to_move) {
                  section_clear = false;
                  break;
                }
              }
              if (section_clear) {
                for (i = _k = col_start; col_start <= col_end ? _k <= col_end : _k >= col_end; i = col_start <= col_end ? ++_k : --_k) {
                  moving_info["col_moves"][i] = blocks_to_move;
                }
              }
              /* If that current, card has not been dealth with*/

              if (__cards_needing_resolved_by_id[id] === void 0 || __cards_needing_resolved_by_id[id] < moving_info["col_moves"][col_start]) {
                __cards_needing_resolved_by_id[id] = moving_info["col_moves"][col_start];
                info = {
                  "id": id,
                  "row": d.row,
                  "row_end": row_end,
                  "col": col_start,
                  "col_end": col_end,
                  "blocks_to_move": moving_info["col_moves"][col_start]
                };
                console.log("data", info);
                _find_conflicting_cards(info);
              }
            }
          }
        }
        return moving_info;
      };
      _adjust_conflicts = function(info) {
        var $card, d, id, new_deck;
        new_deck = {};
        /* For all cards in the deck*/

        for (id in __card_data_by_id) {
          d = __card_data_by_id[id];
          /* That are currently visible*/

          if (d.isRemoved || info.id === id) {
            continue;
          }
          $card = __cards_by_id[id];
          /* If the card conflicts with our expansion*/

          if (__cards_needing_resolved_by_id[id]) {
            /* Move it down a certain amount of spots (calculated previously)*/

            d.row = d.row + __cards_needing_resolved_by_id[id];
          }
          /* Now set the position of the card on our new deck*/

          _set_new_position($card, d, {
            "deck": new_deck
          });
        }
        /* Set the global var to our new deck*/

        return __deck = new_deck;
      };
      set_up_expansion = function($card, changes) {
        var $expand_handle, callback, d, id, _i, _len, _ref4, _results;
        $expand_handle = $card.find(_css_variables.selectors.expand_handle);
        /* Get Card*/

        id = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[id];
        console.log([
          'Expand <<<', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        /* Update Card width/height and save previous dimensions*/

        d['original-col-offset'] = d.col - changes.col;
        d['original-col-span'] = d.col_span;
        d['original-row-span'] = d.row_span;
        d['row_span'] = changes.row_span;
        d['col'] = changes.col;
        d['col_span'] = changes.col_span;
        /* If the card's dimensions aren't 
        if d.col_span == $card.data('original-col-span') and d.row_span == $card.data('original-row-span')
          return;
        */

        console.log([
          'Expand >>>', $card, d, {
            row: d.row,
            col: d.col
          }
        ]);
        /* Set the card's new dimensions*/

        _set_new_position($card, d, {
          "readjust": true
        });
        /* Hide Expansion Handle*/

        $expand_handle.hide();
        $expand_handle.siblings(_css_variables.selectors.collapse_handle).show();
        /* Call callbacks*/

        _ref4 = __event_callbacks[__events.card_expanded] || [];
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          callback = _ref4[_i];
          if (callback($deck, $card) === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      _click_to_expand = function(element) {
        /* Get Card*/

        var $card, $expand_handle, info, moving_info;
        $expand_handle = $(element);
        $card = $expand_handle.closest(_css_variables.selectors.card);
        /* Find the expanded dimensions of the card*/

        info = _find_expansion_size($card);
        /* Identify cards that intersect with this expansion*/

        moving_info = _identify_intersecting_cards(info);
        /* Move conflicts cards*/

        _adjust_conflicts(moving_info);
        /* Expand our new card and call Expansion callbacks*/

        set_up_expansion($card, info);
        /* Apply changes made to each card to UI*/

        _apply_deck();
        /* Clear out global helper variables*/

        return __cards_needing_resolved_by_id = {};
      };
      _on(__events.card_expanded, function($deck, $card) {
        return _card_changed($deck, $card, "card-expanded");
      });
      _on(__events.card_collapsed, function($deck, $card) {
        return _card_changed($deck, $card, "card-collapsed");
      });
    }
    if (options['removable'] && options['removable'] === true) {
      _on(__events.inited, function($card) {
        var controls;
        controls = "<a title='Remove' class='" + _css_variables.classes.remove_handle + " control remove'></a>";
        $card.find(_css_variables.selectors.controls).append(controls);
        return $card.find(_css_variables.selectors.remove_handle).click(function() {
          return _remove_on_click(this);
        });
      });
      _remove_on_click = function(element) {
        var $card, $content, $dropdown, $remove_handle, cardId, charLen, d, deckId, titleText;
        $remove_handle = $(element);
        $card = $remove_handle.closest(_css_variables.selectors.card);
        cardId = parseInt($card.attr('data-card-id'));
        d = __card_data_by_id[cardId];
        $deck = $card.closest(_css_variables.selectors.deck);
        deckId = $deck.attr("id");
        /* Set Title*/

        titleText = $card.find(_css_variables.selectors.card_title).text();
        if (!titleText.length) {
          $content = $card.find(_css_variables.selectors.card_content);
          charLen = _css_variables.chars_to_display;
          if ($content.text().length < _css_variables.chars_to_display) {
            charLen = $content.text().length;
          }
          titleText = $content.text().substring(0, charLen) + "...";
        }
        /* Dropdown Handle*/

        $dropdown = $deck.closest(_css_variables.selectors.deck_container).find(_css_variables.selectors.removed_dropdown);
        if ($dropdown.is(":hidden")) {
          $dropdown.show();
        }
        $dropdown.find('ul').append(_get_removed_card_li_tag(cardId, titleText));
        /*
        Event is currently unpredictable, hold off for now.
        Add card back to orig position (moving other cards if necessary)
        $dropdown.find('#'+_css_variables.classes.removed_card_button + '-' + cardId).click ->
          _add_back_card(cardId)
        */

        /* Add card to open position*/

        $dropdown.find('#' + _css_variables.classes.removed_card_button + '-' + cardId).click(function() {
          __card_data_by_id[cardId].isRemoved = false;
          return _move_to_open_position(cardId, $dropdown);
        });
        /* Detach card from deck*/

        $card.detach();
        /* Remove this card from the __deck variable*/

        _remove_old_position($card, d);
        d.isRemoved = true;
        $dropdown.siblings("#" + deckId + "-nav").find("#" + _css_variables.classes.card_jump_scroll + "-" + cardId).remove();
        return _clean_up_deck();
      };
      _move_to_open_position = function(cardId, $dropdown) {
        var $card, d;
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        $deck.append($card.hide());
        _on(__events.card_moved, function($deck, $card) {
          /*
            Show card once any transition animations are complete (which are called when a user selects a new spot.)
          */

          $card.queue().push(function() {
            return $card.show();
          });
          _add_card_to_jump($card, $dropdown);
          return false;
        });
        _delete_card_from_removed(d.id, $dropdown);
        return $card.find(_css_variables.selectors.droppable).trigger("click");
      };
      _delete_card_from_removed = function(cardId, $dropdown) {
        $dropdown.find('#' + _css_variables.classes.removed_card_li + '-' + cardId).remove();
        if ($dropdown.find('ul').children().size() === 0) {
          return $dropdown.hide();
        }
      };
      _add_card_to_jump = function($card, $dropdown) {
        var $nav_item, classId, elementId, title;
        if (($card.data("title") != null)) {
          title = $card.data('title');
          elementId = $card.attr("data-card-id");
          classId = _css_variables.classes.card_jump_scroll;
          $nav_item = $("<li id='" + (classId + "-" + elementId) + "'><a href='#'>" + title + "</a></li>");
          $nav_item.on('click', function() {
            return _scrollToView($card);
          });
          return $dropdown.siblings(_css_variables.selectors.card_jump_scroll).find('ul').append($nav_item);
        }
      };
      /*
      # Removes the card from the __deck variable so that it doesn't take up space once removed
      */

      _remove_card_from_deck = function($card) {
        var cardId, col, cols, id, row;
        cardId = parseInt($card.attr('data-card-id'));
        for (row in __deck) {
          cols = __deck[row];
          for (col in cols) {
            id = cols[col];
            if (cardId === id) {
              delete __deck[row][col];
              if ($.isEmptyObject(__deck[row])) {
                delete __deck[row];
              }
            }
          }
        }
        return void 0;
      };
      /*
      # Returns the <li> tag for this card, to be shown within the 'Removed Card' dropdown.
      # It displays the card title (or the first 15 characters of the card content, if no title),
      #   and an 'Add' button.
      */

      _get_removed_card_li_tag = function(id, titleText) {
        return "       <li id=" + _css_variables.classes.removed_card_li + "-" + id + "\n       class=" + _css_variables.classes.removed_card_li + ">\n       <a id=" + _css_variables.classes.removed_card_button + "-" + id + ">\n" + titleText + "\n       </a>\n       </li>";
      };
      /*
      # This is the callback when the 'Add' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card = function(cardId) {
        var $card, d;
        if (cardId == null) {
          return;
        }
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        return _add_back_card_helper(cardId, $card, d);
      };
      /*
      # This is the callback when the 'Add to bottom ' button is clicked for the card from the 'Removed Cards' dropdown
      */

      _add_back_card_to_bottom = function(cardId) {
        var $card, can_fit_in_last_row, col, d, _i;
        if (cardId == null) {
          return;
        }
        $card = __cards_by_id[cardId];
        d = __card_data_by_id[cardId];
        can_fit_in_last_row = false;
        for (col = _i = 1; _i <= __col_max; col = _i += 1) {
          if (_does_fit_location(__row_max, col, d)) {
            can_fit_in_last_row = true;
            console.log("fits in max row: __row_max, col: " + __row_max, col);
            break;
          } else {
            console.log$("doesn't fit in max row: __row_max, col: " + __row_max, col);
          }
        }
        if (can_fit_in_last_row) {
          d.row = __row_max;
          d.col = col;
        } else {
          d.row = __row_max + 1;
          d.col = 1;
        }
        return _add_back_card_helper(cardId, $card, d);
      };
      _add_back_card_helper = function(cardId, $card, d) {
        var dropdown;
        $deck.append($card);
        _add_card($card, d);
        _apply_deck();
        _create_jump_scroll_card($deck);
        $deck.parent().find('#' + _css_variables.classes.removed_card_li + '-' + cardId).remove();
        dropdown = $deck.parent().find(_css_variables.selectors.removed_dropdown);
        if (dropdown.find('ul').children().size() === 0) {
          return dropdown.hide();
        }
      };
    }
    if (options['persist'] && options['persist'] === true) {
      _on(__events.inited, function($deck, $card) {
        if (_document.__deck_mgr !== void 0 && _document.__deck_mgr.persistance !== void 0 && _document.__deck_mgr.persistance.url !== void 0) {
          $deck.closest(_css_variables.selectors.deck_container).find(_css_variables.selectors.deck_controls).append(_init_persistence());
          $("#save").bind("click", _saveDeckRemotly);
          return $("#load").bind("click", _loadRemoteDeck);
        }
      });
      _init_persistence = function() {
        return " \n<span>\n  <button id = \"save\">Save</button>\n  <button id = \"load\">Load</button>\n</span>";
      };
      _saveDeckRemotly = function() {
        var $deckClone, $dropdown, deckClone, deckId, persistance, url;
        persistance = _document.__deck_mgr.persistance;
        /* Save DECK*/

        deckId = $deck.attr("id");
        $deckClone = $deck.clone();
        $deckClone.find(_css_variables.selectors.controls).each(function() {
          var $card, $controls, $expandHandle;
          $controls = $(this);
          $expandHandle = $controls.find(_css_variables.selectors.expand_handle);
          $card = $controls.closest(_css_variables.selectors.card);
          if ($expandHandle.css("display") === "none") {
            $card.attr("data-is-expanded", "true");
          }
          $card.find(_css_variables.selectors.controls).remove();
          $card.find(_css_variables.selectors.title).remove();
          $card.find(_css_variables.selectors.drag_mod_handle).remove();
          $card.attr("data-skip-force", "true");
          if ($card.attr("[data-url]") != null) {
            return $card.attr("[data-url]").html("");
          }
        });
        /* Save Removed Cards*/

        $dropdown = $deck.closest(_css_variables.selectors.deck_container).find(_css_variables.selectors.removed_dropdown);
        $dropdown.find("a").each(function(index) {
          var $card, $link, cardId, temp;
          $link = $(this);
          temp = $link.attr("id").indexOf(_css_variables.classes.removed_card_button) + _css_variables.classes.removed_card_button.length + 1;
          cardId = parseInt($link.attr("id").substring(temp));
          $card = __cards_by_id[cardId].clone();
          /* Take Note: Card State (expanded/collapsed)*/

          if ($card.find(_css_variables.selectors.expand_handle).css("display") === "none") {
            $card.attr("data-is-expanded", "true");
          }
          /* Take Note: Removed Card*/

          $card.attr("data-is-removed", "true");
          /* Remove content this regenerated when deck is loaded*/

          $card.find(_css_variables.selectors.controls).remove();
          $card.find(_css_variables.selectors.title).remove();
          $card.find(_css_variables.selectors.drag_mod_handle).remove();
          $card.find(_css_variables.selectors.card_content + "[data-url]").html("");
          return $deckClone.append($card);
        });
        deckClone = $deckClone[0].outerHTML;
        deckId = $deck.attr("id");
        /* Create REST call*/

        if (persistance != null) {
          url = {
            "url": persistance.url,
            "type": "POST",
            "success": function(data, status, response) {
              var __is_saved;
              console.log("successfully saved deck preferences");
              return __is_saved = true;
            },
            "error": function(response, status, exception) {
              return console.log("unsuccessfully saved deck preferences");
            }
          };
          url.data = {};
          url.data[deckId] = {};
          url.data[deckId].layout = deckClone;
          return _ajax(url);
        }
        /* Only Persist Locally*/

      };
      _reset_deck = function() {
        __next_id = 1;
        __deck = {};
        __cards_by_id = {};
        __card_data_by_id = {};
        __col_max = 0;
        return __row_max = 0;
      };
      _loadRemoteDeck = function() {
        var persistance, url, __is_saved;
        if (_document.__deck_mgr !== void 0 && _document.__deck_mgr.persistance !== void 0 && _document.__deck_mgr.persistance.url !== void 0) {
          persistance = _document.__deck_mgr.persistance;
          url = {
            "url": persistance.url,
            "type": "GET",
            "success": function(data, status, response) {
              var deckId, layout, str, __is_saved;
              str = "No Deck Saved";
              if (data._id === "undefined" || data._id === void 0) {
                __is_saved = false;
                _reset_deck();
                init();
              } else {
                str = "Loading Saved Deck";
                deckId = $deck.attr("id");
                layout = data[deckId].layout;
                /* Add back saved deck*/

                if ($deck.closest(_css_variables.selectors.deck_container).length > 0) {
                  console.log("Replacing Deck Container");
                  $deck.closest(_css_variables.selectors.deck_container).replaceWith(layout);
                } else {
                  console.log("Replacing Deck");
                  $deck.replaceWith(layout);
                }
                _reset_deck();
                /* Set new deck handle*/

                $deck = $("#" + deckId);
                __is_saved = true;
                /* INIT*/

                init();
                $("[data-is-expanded='true'] " + _css_variables.selectors.expand_handle).each(function() {
                  var $card, callback, _i, _len, _ref4, _results;
                  $card = $(this).closest(_css_variables.selectors.card);
                  $deck = $(this).closest(_css_variables.selectors.deck);
                  $card.removeAttr("data-is-expanded");
                  $(this).hide();
                  $(this).siblings(_css_variables.selectors.collapse_handle).show();
                  _ref4 = __event_callbacks[__events.card_expanded] || [];
                  _results = [];
                  for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                    callback = _ref4[_i];
                    if (callback($deck, $card) === false) {
                      break;
                    } else {
                      _results.push(void 0);
                    }
                  }
                  return _results;
                });
                $("[data-is-removed='true'] " + _css_variables.selectors.remove_handle).each(function() {
                  console.log("card-id", $(this).closest(_css_variables.selectors.card).data("card-id"));
                  $(this).closest(_css_variables.selectors.card).removeAttr("data-is-removed");
                  return $(this).trigger('click');
                });
                $("[data-skip-force='true']").removeAttr('data-skip-force');
              }
              return console.log(str);
            },
            "error": function(response, status, exception) {
              console.log("Error Loading Deck");
              return init();
            }
          };
          return _ajax(url);
        } else {
          __is_saved = false;
          _reset_deck();
          init();
        }
        return void 0;
      };
      _localMgr = function(option) {
        return false;
        if (typeof (typeof Storage !== "undefined" && Storage !== null)) {
          if (option.load && localStorage.deck) {
            console.log("Loading Locally Saved Deck");
            console.log("DECK " + JSON.parse(localStorage.deck));
            __deck = JSON.parse(localStorage.deck);
            _apply_deck();
            return true;
          } else if (option.save != null) {
            console.log("Saving Deck Locally");
            localStorage.deck = JSON.stringify(__deck);
            return true;
          }
        }
        return false;
      };
    }
    _loadRemoteDeck();
    return deckster = {
      deck: __deck,
      on: _on,
      events: __events
    };
  };

  $ = jQuery;

  $.fn.deckster = window.Deckster;

  _document = $(document);

}).call(this);
